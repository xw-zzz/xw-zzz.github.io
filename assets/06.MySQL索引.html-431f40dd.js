import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as s,c as o,a as e,e as a,d as n,b as r}from"./app-ef0b4d9d.js";const d="/assets/20220628082422-d1843f78.png",p="/assets/20220628223858-27deffdc.png",h="/assets/20220628225907-730bc318.png",c="/assets/20220628230042-fce67da0.png",u="/assets/20220628230146-ea84e20e.png",g="/assets/20220628231050-379c8fb2.png",_="/assets/20220628234852-8128516b.png",b="/assets/image-20230721161707406-da93bc3a.png",f="/assets/20220906101329-fbc300a5.png",m="/assets/20220906111403-363ae6c5.png",y="/assets/20220906110256-293be9b1.png",x="/assets/20220906110543-23a5448c.png",k="/assets/image-20230721180009717-81eb70ab.png",E={},B=r('<div class="hint-container info"><p class="hint-container-title">索引是最好的解决方案吗？</p><p>索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。</p><p>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存储在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于大型系统，这是一个常用的技巧。事实上，Infobright就是使用类似的实现。对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。</p><div style="text-align:right;"><p>来自 《高性能MySQL》</p></div></div><h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><p>索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能，除此之外，本章还将讨论索引其他一些方面有用的属性。</p><h1 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构" aria-hidden="true">#</a> 索引数据结构</h1><p>索引有不同的数据结构，可以为不同的场景提供更好的性能。</p><h2 id="b-tree索引-👍" tabindex="-1"><a class="header-anchor" href="#b-tree索引-👍" aria-hidden="true">#</a> B-Tree索引（👍）</h2><p>B-TREE 是一个多叉数，每个节点都是一个二元数组: [key, data]，所有节点都可以存储数据。key为索引key,data为除key之外的数据，B-TREE可以满足等值查询、范围查询的要求，但是插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。因为所有节点都存储了数据，区间查找可能需要返回上层节点重复遍历，IO操作繁琐。B-Tree的结构如下图所示：<br><img src="'+d+'" alt="" loading="lazy"><br> B+TREE在B-TREE的基础上做了以下改进：</p><ul><li>非叶子节点不存储数据，只存储索引key，只有叶子节点存储数据，只利用索引快速定位数据索引范围，先定位索引再通过索引高效快速定位数据。</li><li>叶子节点存储了指向下一个节点的指针，在范围查询时可加快查询性能。<br><img src="'+p+'" alt="" loading="lazy"></li></ul><p>以主键索引为例，检索过程如下所示：</p><ul><li><p>等值检索</p><p><img src="'+h+'" alt="" loading="lazy"><br> 查找id为23记录，确定定位条件, 找到根节点Page No, 根节点读到内存, 逐层向下查找, 读取叶子节点Page,通过 二分查找找到记录或未命中</p></li><li><p>范围查找</p><p><img src="'+c+'" alt="" loading="lazy"></p><p>查找id为18到23的记录：读取根节点至内存, 确定索引定位条件id=18, 找到满足条件第一个叶节点, 顺序扫描所有结果, 直到终止条件满足id &gt;=21</p></li><li><p>全表扫描</p><p><img src="'+u+'" alt="" loading="lazy"> 直接读取叶节点头结点， 顺序扫描， 返回符合条件记录， 到最终节点结束。</p></li></ul><p>非主键索引查找:</p><p><img src="'+g+'" alt="" loading="lazy"></p><p>非主键索引存的是主键值，查到主键值后再查询数据。</p><p>联合索引：</p><p><img src="'+_+'" alt="" loading="lazy"></p><p>与单个索引不一样的是存储的key包含多个值，按照顺序存放，因此使用唯一索引需要遵从最左匹配原则。</p><h2 id="全文索引" tabindex="-1"><a class="header-anchor" href="#全文索引" aria-hidden="true">#</a> 全文索引</h2><p>FULLTEXT是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干、复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。（一般不用）</p><h2 id="哈希索引" tabindex="-1"><a class="header-anchor" href="#哈希索引" aria-hidden="true">#</a> 哈希索引</h2><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效进。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码,哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<strong>在MySQL中，只有Memory引擎显式支持哈希索引</strong>。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p><h1 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> 索引类型</h1><h2 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h2><p>在InnoDB中聚簇索引实际上在同一个结构中保存了B-tree索引和数据行，一个表只能有一个聚簇索引。如图标记所示，索引跟数据存储在一起。</p><p><img src="'+b+'" alt="" loading="lazy"></p><blockquote><p>优点：</p></blockquote><ul><li>访问数据速度更快。因为聚簇索引将索引和数据保存在同一个B-tree中。</li></ul><blockquote><p>缺点：</p></blockquote><ul><li>更新聚簇索引列的代价很高，因为它会强制InnoDB将每个被更新的行移动到新的位置。</li><li>插入速度严重依赖于插入顺序。按照主键的顺序插入行是将数据加载到InnoDB表中最快的方式。一般使用自增主键，避免使用随机聚簇索引，因为索引要保证顺序性，使用随机索引会导致频繁的页分裂和碎片。</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>在InnoDB中，主键为聚簇索引，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有则会隐性定义一个主键作为聚簇索引，这样会导致所有需要使用这种隐藏主键的表都依赖一个单点的主键自增，这可能会导致非常高的锁竞争，从而出现性能问题。</p></div><h2 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h2><p>覆盖索引（Covering Index）是一种特殊类型的索引，它包含了查询所需的所有数据列，从而避免了数据库查询时访问实际数据行，直接通过索引本身就能够满足查询的需求。通过使用覆盖索引，可以显著提高查询性能，减少查询的执行时间和资源消耗。</p><blockquote><p>优点：</p></blockquote><ul><li>减少IO操作：由于覆盖索引直接包含了查询所需的数据列，查询可以在索引层完成，减少了对实际数据行的IO操作，从而提高了查询性能。</li></ul><blockquote><p>缺点：</p></blockquote><ul><li>更新代价：当表的数据发生变化时（插入、更新、删除），覆盖索引也需要进行相应的更新。</li></ul><h1 id="高性能索引" tabindex="-1"><a class="header-anchor" href="#高性能索引" aria-hidden="true">#</a> 高性能索引</h1><ul><li><p>独立的列，索引不能是表达式的一部分，也不能是函数的参数。</p></li><li><p>选择区分度高的字段去做索引。</p></li><li><p>组合索引选择合适的索引列顺序，将选择性最高的列放到最前面通常是最好的。</p></li><li><p>使用覆盖索引，如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。</p></li><li><p>**避免使用select, **<code>select *</code>不会走<code>覆盖索引</code>，会出现大量的<code>回表</code>操作，而从导致查询sql的性能很低，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。</p></li><li><p><strong>用union all代替union</strong>，<code>union</code>关键字后，可以获取排重后的数据，<code>union all</code>关键字，可以获取所有数据，包含重复的数据，排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。</p></li><li><p>小表驱动大表。</p><ul><li><code>in</code> 适用于左边大表，右边小表。如果sql语句中包含了in关键字，则它会优先执行in里面的<code>子查询语句</code>，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快</li><li><code>exists</code> 适用于左边小表，右边大表。exists优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。</li></ul></li><li><p>join的表不宜过多，根据阿里巴巴开发者手册的规定，join表的数量不应该超过<code>3</code>个。</p></li><li><p>join注意事项</p><p>join使用最多的是left join和inner join。</p><ul><li><p><code>left join</code>：求两个表的交集外加左表剩下的数据。mysql会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题</p></li><li><p><code>inner join</code>：求两个表交集的数据。inner join关联，mysql会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题</p><div class="hint-container warning"><p class="hint-container-title">注意事项</p><p>要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。</p></div></li></ul></li><li><p>单表的索引数量应该尽量控制在<code>5</code>个以内，并且单个索引中的字段数不超过<code>5</code>个</p></li><li><p>联合索引注意最左匹配原则：按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)然后停止匹配。</p></li><li><p>避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效。</p></li></ul><h2 id="索引失效常见原因" tabindex="-1"><a class="header-anchor" href="#索引失效常见原因" aria-hidden="true">#</a> 索引失效常见原因</h2><p><img src="'+f+'" alt="" loading="lazy"></p><h2 id="explain索引优化" tabindex="-1"><a class="header-anchor" href="#explain索引优化" aria-hidden="true">#</a> EXPLAIN索引优化</h2><p>EXPLAIN语句提供了MySQL如何执行语句的信息。EXPLAIN适用于SELECT、DELETE、INSERT、REPLACE和UPDATE语句。相关字段如下：</p><p><img src="'+m+'" alt="" loading="lazy"></p><h3 id="id列" tabindex="-1"><a class="header-anchor" href="#id列" aria-hidden="true">#</a> id列</h3><ul><li>序号相同从上到下顺序执行</li><li>序号不相同的从大到小顺序执行</li><li>既有相同又有不同的，先按照序号从大到小执行，相同的从上到下执行</li></ul><h3 id="select-type" tabindex="-1"><a class="header-anchor" href="#select-type" aria-hidden="true">#</a> select_type</h3><p><img src="'+y+'" alt="" loading="lazy"></p><h3 id="table列" tabindex="-1"><a class="header-anchor" href="#table列" aria-hidden="true">#</a> table列</h3><p>所引用表的名称</p><h3 id="partitions列" tabindex="-1"><a class="header-anchor" href="#partitions列" aria-hidden="true">#</a> partitions列</h3><p>匹配记录的分区</p><h3 id="type列" tabindex="-1"><a class="header-anchor" href="#type列" aria-hidden="true">#</a> type列</h3><p><img src="'+x+'" alt="" loading="lazy"></p><h3 id="possible-keys列" tabindex="-1"><a class="header-anchor" href="#possible-keys列" aria-hidden="true">#</a> possible_keys列</h3><p>该列表示可能的索引选择。</p><h3 id="key列" tabindex="-1"><a class="header-anchor" href="#key列" aria-hidden="true">#</a> key列</h3><p>该列表示实际用到的索引。</p><h3 id="key-len列" tabindex="-1"><a class="header-anchor" href="#key-len列" aria-hidden="true">#</a> key_len列</h3><p>该列表示使用索引的长度。上面的key列可以看出有没有使用索引，key_len列则可以更进一步看出索引使用是否充分。</p><h3 id="ref列" tabindex="-1"><a class="header-anchor" href="#ref列" aria-hidden="true">#</a> ref列</h3><p>该列表示索引命中的列或者常量。</p><h3 id="rows列" tabindex="-1"><a class="header-anchor" href="#rows列" aria-hidden="true">#</a> rows列</h3><p>该列表示MySQL认为执行查询必须检查的行数。</p><h3 id="filtered列" tabindex="-1"><a class="header-anchor" href="#filtered列" aria-hidden="true">#</a> filtered列</h3><p>该列表示按表条件过滤的表行的估计百分比。最大值为100，这表示未过滤行。值从100减小表示过滤量增加。</p><h3 id="extra列" tabindex="-1"><a class="header-anchor" href="#extra列" aria-hidden="true">#</a> Extra列</h3>',65),I=r("<li><p><strong>Impossible WHERE</strong>，表示WHERE后面的条件一直都是false</p></li><li><p><strong>Using filesort</strong>，表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现</p></li><li><p><strong>Using index</strong>，表示是否用了覆盖索引，说白了它表示是否所有获取的列都走了索引。</p></li><li><p><strong>Using temporary</strong>，临时表</p></li><li><p><strong>Using where</strong>，where条件过滤</p></li>",5),L={href:"https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra",target:"_blank",rel:"noopener noreferrer"},T=r('<h1 id="索引命名规范" tabindex="-1"><a class="header-anchor" href="#索引命名规范" aria-hidden="true">#</a> 索引命名规范</h1><p><img src="'+k+'" alt="" loading="lazy"></p><h1 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h1>',3),q={href:"https://dev.mysql.com/doc/refman/8.0/en/explain-output.html",target:"_blank",rel:"noopener noreferrer"},z={href:"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490262&idx=1&sn=a67f610afa984ecca130a54a3be453ab&source=41#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},M=e("li",null,"阿里Java开发规范",-1);function v(j,w){const i=t("ExternalLinkIcon");return s(),o("div",null,[B,e("ul",null,[I,e("li",null,[e("p",null,[a("其他类型参考 "),e("a",L,[a("Extra描述"),n(i)])])])]),T,e("ul",null,[e("li",null,[e("a",q,[a("MySQL explain官方文档"),n(i)])]),e("li",null,[e("a",z,[a("索引优化的这把绝世好剑，你真的会用吗？"),n(i)])]),M])])}const Q=l(E,[["render",v],["__file","06.MySQL索引.html.vue"]]);export{Q as default};

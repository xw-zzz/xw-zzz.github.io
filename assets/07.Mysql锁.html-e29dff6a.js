import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as a,d as r,w as o,b as s,a as l,e as d}from"./app-ef0b4d9d.js";const c="/assets/20220908104056-5de3e9da.png",u={},h=s('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并<br> 发访问。</p><h2 id="锁分类" tabindex="-1"><a class="header-anchor" href="#锁分类" aria-hidden="true">#</a> 锁分类</h2><p><img src="'+c+'" alt="" loading="lazy"></p><p>锁的分类</p><ul><li>从对数据操作的类型分法（读或写） <ul><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul></li><li>从对数据操作的粒度分法 <ul><li>表级锁：表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁</li><li>行级锁：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁</li><li>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，一次锁定相邻的一组记录</li></ul></li><li>从并发角度的分发--实际上乐观锁和悲观锁只是一种思想 <ul><li>悲观锁：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观) ，因此，在整个数据处理过程中，将数据处于锁定状态。</li><li>乐观锁：乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息再进行业务重试</li></ul></li><li>其他锁： <ul><li>间隙锁：在条件查询中，如：where id&gt;100，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，间隙的目的是为了防止幻读</li><li>意向锁：意向锁分为 intention shared lock (IS) 和 intention exclusive lock (IX)，意向锁的目的就是表明有事务正在或者将要锁住某个表中的行</li></ul></li></ul><h3 id="行锁与表锁" tabindex="-1"><a class="header-anchor" href="#行锁与表锁" aria-hidden="true">#</a> 行锁与表锁</h3><ul><li><p>表级锁是MySQL中<strong>锁定粒度最大</strong>的一种锁，表示对当前操作的整张表加锁，它实现简单。最常使用的MYISAM与INNODB都支持表级锁定。</p><ul><li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul></li><li><p>行级锁是Mysql中<strong>锁定粒度最细</strong>的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。</p><ul><li><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</p></li><li><p>使用：InnoDB行锁是通过给索引上的索引项加锁来实现的。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p></div></li></ul></li><li><p>行级锁改为表级锁的案例--不命中索引场景</p></li></ul><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><p><strong>死锁概念</strong>：死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相待<br> 的现象。</p>',10),p=l("ul",null,[l("li",null,"在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）"),l("li",null,"批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路） A线程 id：1 ,10 ,20按顺序加锁 B线程id:20,10,1"),l("li",null,"如果可以，大事务化成小事务，甚至不开启事务 select for update==>insert==>update = insert into update on duplicate key"),l("li",null,"尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表 有走索引记录锁，没走索引表锁"),l("li",null,"使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响 1，10，20 等值where id in (1,10,20) 范围查询 id>1 and id<20"),l("li",null,"避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行"),l("li",null,"设置超时时间")],-1);function _(f,m){const i=n("font");return t(),a("div",null,[h,r(i,{color:"#4bacc6"},{default:o(()=>[d("**如何有效避免死锁**：")]),_:1}),p])}const y=e(u,[["render",_],["__file","07.Mysql锁.html.vue"]]);export{y as default};

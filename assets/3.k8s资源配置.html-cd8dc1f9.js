import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as d,b as s}from"./app-ef0b4d9d.js";const n={},r=s(`<ul><li><p><strong>pod的yaml文件示例</strong></p><ul><li><p>yaml文件示例：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># pod的最基础的yaml文件最少需要以下的几个参数</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1 <span class="token comment"># API版本号，注意：具有多个，不同的对象可能会使用不同API</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod  <span class="token comment"># 对象类型，pod</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token comment"># 元数据</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> string <span class="token comment"># POD名称</span>
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> string <span class="token comment"># 所属的命名空间</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment"># specification of the resource content(资源内容的规范)</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment"># 容器列表</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string <span class="token comment"># 容器名称</span>
      <span class="token key atrule">image</span><span class="token punctuation">:</span> string <span class="token comment"># 容器镜像</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>常用字段含义</strong></p><ul><li><p><strong>必须存在的属性</strong></p><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td>version</td><td>String</td><td>k8s API的版本，可使用kubectl api-versions命令查询</td></tr><tr><td>kind</td><td>String</td><td>这里指定k8s资源的类型，比如Pod、Deployment</td></tr><tr><td>metadata</td><td>Object</td><td>元数据对象，固定写值metadata</td></tr><tr><td>metadata-name</td><td>String</td><td>元数据对象的名字，比如命名pod的名字</td></tr><tr><td>metadata-namespace</td><td>String</td><td>元数据对象的命名空间</td></tr><tr><td>spec</td><td>Object</td><td>详细定义对象，固定值写Spec</td></tr><tr><td>spec.container[]</td><td>list</td><td>spec对象的容器列表定义</td></tr><tr><td>spec.container[].name</td><td>String</td><td>容器对象的名字</td></tr><tr><td>spec.container[].image</td><td>String</td><td>定义要用到的对象名称</td></tr></tbody></table></li><li><p>spec主要对象【大体知道即可】</p><ul><li>spec.containers</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td>spec.containers[].name</td><td>String</td><td>定义容器的名字</td></tr><tr><td>spec.containers[].image</td><td>String</td><td>定义要用到的镜像名称</td></tr><tr><td>spec.containers[].imagePullPolicy</td><td>String</td><td>定义镜像拉取策略，有Always、Never、IfNotPresent三个值可选（1）Always：意思是每次都尝试重新拉取镜像 （2）Never：表示仅使用本地镜像 （3）IfNotPresent：如果本地有镜像就使用本地镜像，没有就拉取在线镜像。 上面三个值都没设置的话，默认是Always。</td></tr><tr><td>spec.containers[].command[]</td><td>List</td><td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td></tr><tr><td>spec.containers[].args[]</td><td>List</td><td>指定容器启动命令参数，因为是数组可以指定多个。</td></tr><tr><td>spec.containers[].workingDir</td><td>String</td><td>指定容器的工作目录</td></tr><tr><td>spec.containers[].volumeMounts[]</td><td>List</td><td>指定容器内部的存储卷配置</td></tr><tr><td>spec.containers[].volumeMounts[].name</td><td>String</td><td>指定可以被容器挂载的存储卷的名称</td></tr><tr><td>spec.containers[].volumeMounts[].mountPath</td><td>String</td><td>指定可以被容器挂载的存储卷的路径</td></tr><tr><td>spec.containers[].volumeMounts[].readOnly</td><td>String</td><td>设置存储卷路径的读写模式，ture 或者false，默认为读写模式</td></tr><tr><td>spec.containers[].ports[]</td><td>List</td><td>指定容器需要用到的端口列表</td></tr><tr><td>spec.containers[].ports[].name</td><td>String</td><td>指定端口名称</td></tr><tr><td>spec.containers[].ports[].containerPort</td><td>String</td><td>指定容器需要监听的端口号</td></tr><tr><td>spec.containers[].ports[].hostPort</td><td>String</td><td>指定容器所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了hostPort 同一台主机无法启动该容器的相同副本（因为主机的端口号不能相同，这样会冲突）</td></tr><tr><td>spec.containers[].ports[].protocol</td><td>String</td><td>指定端口协议，支持TCP和UDP，默认值为TCP</td></tr><tr><td>spec.containers[].env[]</td><td>List</td><td>指定容器运行前需设置的环境变量列表</td></tr><tr><td>spec.containers[].env[].name</td><td>String</td><td>指定环境变量名称</td></tr><tr><td>spec.containers[].env[].value</td><td>String</td><td>指定环境变量值</td></tr><tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr><tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指定设置容器运行时资源的运行上限</td></tr><tr><td>spec.containers[].resources.limits.cpu</td><td>String</td><td>指定CPU的限制，单位为core数，将用于 docker run --cpu-shares参数（这里前面文章Pod资源限制有讲过）</td></tr><tr><td>spec.containers[].resources.limits.memory</td><td>String</td><td>指定MEM内存的限制，单位为MIB、GiB</td></tr><tr><td>spec.containers[].resources.requests</td><td>Object</td><td>指定容器启动和调度时的限制设置</td></tr><tr><td>spec.containers[].resources.requests.cpu</td><td>String</td><td>CPU请求，单位为core数，容器启动时初始化可用数量</td></tr><tr><td>spec.containers[].resources.requests.memory</td><td>String</td><td>内存请求，单位为MIB、GiB，容器启动的初始化可用数量</td></tr></tbody></table><ul><li>spec.volumes</li></ul><table><thead><tr><th>参数名</th><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td>spec.volumes[].name</td><td>String</td><td>定义Pod的共享存储卷的名称，容器定义部分的spec.containers[].volumeMounts[].name的值跟这里是一样的。</td></tr><tr><td>spec.volumes[].emptyDir</td><td>Object</td><td>指定Pod的临时目录，值为一个空对象：emptyDir:{}</td></tr><tr><td>spec.volumes[].hostPath</td><td>Object</td><td>指定挂载Pod所在宿主机的目录</td></tr><tr><td>spec.volumes[].hostPath.path</td><td>String</td><td>指定Pod所在主机的目录，将被用于容器中mount的目录</td></tr><tr><td>spec.volumes[].secret</td><td>Object</td><td>指定类型为secret的存储卷，secret意为私密、秘密的意思，很容易理解，它存储一些密码，token或者秘钥等敏感安全文件。挂载集群预定义的secret对象到容器内部。</td></tr><tr><td>spec.volumes[].configMap</td><td>Object</td><td>指定类型为configMap的存储卷，表示挂载集群预定义的configMap对象到容器内部。</td></tr><tr><td>spec.volumes[].livenessProbe</td><td>Object</td><td>指定Pod内容器健康检查的设置，当探测无响应几次后，系统将自动重启该容器。这个在前面的文章中有说，具体可以设置：exec、httpGet、tcpSocket。</td></tr><tr><td>spec.volumes[].livenessProbe.exec</td><td>Object</td><td>指定Pod内容器健康检查的设置，确定是exec方式</td></tr><tr><td>spec.volumes[].livenessProbe.exec.command[]</td><td>String</td><td>指定exec方式后需要指定命令或者脚本，用这个参数设置</td></tr><tr><td>spec.volumes[].livenessProbe.httpGet</td><td>Object</td><td>指定Pod内容器健康检查的设置，确定是httpGet方式</td></tr><tr><td>spec.volumes[].livenessProbe.tcpSocket</td><td>Object</td><td>指定Pod内容器健康检查的设置，确定是tcpSocket方式</td></tr><tr><td>spec.volumes[].livenessProbe.initialDelaySeconds</td><td>Number</td><td>容器启动完成后手册探测的时间设置，单位为s</td></tr><tr><td>spec.volumes[].livenessProbe.timeoutSeconds</td><td>Number</td><td>对容器健康检查的探测等待响应的超时时间设置，单位为S，默认为1s。若超过该超时时间设置，则认为该容器不健康，会重启该容器。</td></tr><tr><td>spec.volumes[].livenessProbe.periodSeconds</td><td>Number</td><td>对容器健康检查的定期探测时间设置，单位为S，默认10s探测一次。</td></tr></tbody></table></li></ul></li></ul>`,1),a=[r];function c(o,i){return e(),d("div",null,a)}const u=t(n,[["render",c],["__file","3.k8s资源配置.html.vue"]]);export{u as default};

import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as l,f as c,a,e,d as s,b as t}from"./app-ef0b4d9d.js";const o="/assets/100-aea7210c.jpeg",u="/assets/MapClassHierarchy600x354-34b5fd5e-5e38fa91.jpg",v="/assets/accesslevel-17093c67-d82b28f0.png",g="/assets/javacollectionhierarchy-e17306c4-e9f57d35.jpeg",b="/assets/arraylistvslinkedlistcomplexity-2546b6b8-24bac9b3.png",p="/assets/arraylistvslinkedlist1-6838cb4d-146d211a.png",m="/assets/constructorvsdoublequotesJavaStringNewPage650x324-2d02ea02-4832c5ca.png",h="/assets/772dedd20f0443648fe19bf102c78efa-7ad8c0d8-33e636f4.jpeg",x={},_=t('<hr><p><img src="'+o+`" alt="" loading="lazy"></p><h3 id="_1-将-array-转换成-arraylist" tabindex="-1"><a class="header-anchor" href="#_1-将-array-转换成-arraylist" aria-hidden="true">#</a> 1.将 Array 转换成 ArrayList</h3><p>通常我们将 Array 转成 ArrayList 都是使用下面的语法，</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>List&lt;String&gt; list = Arrays.asList(arr);  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Arrays.asList()方法将返回 ArrayList，它是 Arrays 中的一个私有静态类而不是 java.util.ArrayList 类。 <code>java.util.Arrays.ArrayList</code>类具有 set ()、 get ()和 contains ()方法，但没有任何用于添加元素的方法，因此其大小是固定的。 要创建一个真正的 ArrayList，你应该这样做:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,7),y=t(`<hr><h3 id="_2-检查数组是否包含值" tabindex="-1"><a class="header-anchor" href="#_2-检查数组是否包含值" aria-hidden="true">#</a> 2.检查数组是否包含值</h3><p>常见错误做法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr));
return set.contains(targetValue);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个代码可以达到我们的目的，但是不需要转换 将列表转换为集合需要额外的时间。 可以简化成:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Arrays.asList(arr).contains(targetValue);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="_3-从循环列表中删除某个元素" tabindex="-1"><a class="header-anchor" href="#_3-从循环列表中删除某个元素" aria-hidden="true">#</a> 3.从循环列表中删除某个元素</h3><p>错误做法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
for (int i = 0; i &lt; list.size(); i++) {
	list.remove(i);
}
System.out.println(list);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：<br><code>[b, d]</code><br> 这种方法有一个严重的问题。删除元素时，列表的大小会缩小，索引也会发生变化。因此，如果您希望通过使用索引来删除循环中的多个元素，那将无法正常工作。<br> 您可能知道使用迭代器是在循环中删除元素的正确方法，而且您知道 Java 中的 foreach 循环工作起来像迭代器，但实际上并非如此。代码如下。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
 
for (String s : list) {
	if (s.equals(&quot;a&quot;))
		list.remove(s);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),f={href:"https://www.programcreek.com/2014/01/java-util-concurrentmodificationexception/",target:"_blank",rel:"noopener noreferrer"},q=a("br",null,null,-1),L=t(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
Iterator&lt;String&gt; iter = list.iterator();
while (iter.hasNext()) {
	String s = iter.next();
 
	if (s.equals(&quot;a&quot;)) {
		iter.remove();
	}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="next-必须在-remove-之前调用。" tabindex="-1"><a class="header-anchor" href="#next-必须在-remove-之前调用。" aria-hidden="true">#</a> <code>.next()</code> 必须在 <code>.remove()</code>之前调用。</h2><h3 id="_4-hashtable-vs-hashmap" tabindex="-1"><a class="header-anchor" href="#_4-hashtable-vs-hashmap" aria-hidden="true">#</a> 4.Hashtable vs HashMap</h3><p>map预览<br><img src="`+u+`" alt="MapClassHierarchy600x354.jpg" loading="lazy"></p><ul><li>HashMap：底层由哈希表实现，对键或值没有排序。</li><li>TreeMap：基于红黑树实现，并按键排序。</li><li>Hashtable：与 HashMap 相反，Hashtable 是同步的。 它有一个同步的开销。</li><li>LinkedHashMap：保留插入顺序，有序。</li></ul><p>注意项：<br><strong>如果 HashMap 的键是一个自定义对象，那么需要遵循 equals ()和 hashCode ()契约。</strong><br><strong>由于 TreeMaps 是按键排序的，因此 key 的对象必须能够相互比较，这就是它必须实现 Comparable 接口的原因</strong></p><h3 id="_5-使用原始类型-object-的集合" tabindex="-1"><a class="header-anchor" href="#_5-使用原始类型-object-的集合" aria-hidden="true">#</a> 5.使用原始类型(Object)的集合</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public static void add(List list, Object o){
	list.add(o);
}
public static void main(String[] args){
	List&lt;String&gt; list = new ArrayList&lt;String&gt;();
	add(list, 10);
	String s = list.get(0);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这段会出现如下报错信息：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
	at ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用原始类型集合是危险的-因为原始类型集合跳过了泛型类型检查-并且不安全。" tabindex="-1"><a class="header-anchor" href="#使用原始类型集合是危险的-因为原始类型集合跳过了泛型类型检查-并且不安全。" aria-hidden="true">#</a> 使用原始类型集合是危险的，因为原始类型集合跳过了泛型类型检查，并且不安全。</h2><p>###6. 访问级别<br> 开发人员经常使用 public 作为类字段。 通过直接引用字段值很方便，但这是一个非常糟糕的设计。 正确的做法是尽可能低为成员提供低的访问级别。<br> 下表总结了成员的不同修饰符的访问级别，访问级别决定字段和方法的可访问性。 它有4个级别: public、 protected、 package-private (没有显式修饰符)或 private。<br><img src="`+v+'" alt="accesslevel.png" loading="lazy"></p><h3 id="_7-arraylist-vs-linkedlist" tabindex="-1"><a class="header-anchor" href="#_7-arraylist-vs-linkedlist" aria-hidden="true">#</a> 7.ArrayList vs. LinkedList</h3><p>当开发人员不知道 ArrayList 和 LinkedList 之间的区别时，他们通常使用 ArrayList，因为它看起来很熟悉。 然而，它们之间存在着巨大的性能差异。<br> 集合预览图如下。<br><img src="'+g+'" alt="javacollectionhierarchy.jpeg" loading="lazy"><br> Arraylist 由一个可调整大小的数组实现。 随着更多的元素被添加到 ArrayList 中，它的大小会动态增加。 它的元素可以通过 get 和 set 方法直接访问，因为 ArrayList 实际上是一个数组。<br> Linkedlist 实现为双链表。 它在添加和删除方面的性能优于数组列表，但在 get 和 set 方法上性能较差。<br> 时间复杂度比较如下：<br><img src="'+b+'" alt="arraylistvslinkedlistcomplexity.png" loading="lazy"><br> 性能比较：<br><img src="'+p+`" alt="arraylistvslinkedlist1.png" loading="lazy"><br> 他们的表现有明显的差异。 Linkedlist 在添加和删除方面更快，但在 get 方面更慢。 根据复杂度表和测试结果，我们可以确定何时使用 ArrayList 或 LinkedList。 简而言之，如果下列情况下 LinkedList 应该是首选的：</p><ul><li>元素没有大量的随机存取</li><li>有大量的添加 / 删除操作</li></ul><hr><h3 id="_8-可变对象vs不可变对对象" tabindex="-1"><a class="header-anchor" href="#_8-可变对象vs不可变对对象" aria-hidden="true">#</a> 8.可变对象VS不可变对对象</h3><p>不可变对象有许多优点，如简单性、安全性等。 但是，对于每个不同的值，它需要一个单独的对象，而且对象太多可能会导致垃圾收集的高成本。 在可变和不可变之间进行选择时，应该有一个平衡。<br> 通常，使用可变对象是为了避免产生过多的中间对象。 一个典型的例子是连接大量的字符串。 如果使用不可变字符串，则会生成许多可立即进行垃圾收集的对象。 这会浪费 CPU 的时间和精力，而使用可变对象是正确的解决方案（<code>StringBuilder</code>）</p><hr><h3 id="_9-父类和子类构造器" tabindex="-1"><a class="header-anchor" href="#_9-父类和子类构造器" aria-hidden="true">#</a> 9.父类和子类构造器</h3><p><img src="https://img.hacpai.com/file/2019/12/Implicitsuperconstructorisundefinedfordefaultconstructor-7abcade6.png" alt="Implicitsuperconstructorisundefinedfordefaultconstructor.png" loading="lazy"><br> 由于未定义默认父类构造函数，因此发生此编译错误。 在 Java 中，如果类没有定义构造函数，编译器将默认为类插入默认的无参数构造函数。 如果在 Super 类中定义了一个构造函数，在这种情况下，Super (String s) ，编译器不会插入默认的无参数构造函数。 这就是上面提到的父类的情况。</p><hr><h3 id="_10-使用-还是构造器初始化string" tabindex="-1"><a class="header-anchor" href="#_10-使用-还是构造器初始化string" aria-hidden="true">#</a> 10.使用&quot;&quot;还是构造器初始化String</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//1. 使用双引号
String x = &quot;abc&quot;;
//2. 构造器方式
String y = new String(&quot;abc&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们分析一下他们之间的区别：</p><p><strong>例子1</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>String a = &quot;abcd&quot;;
String b = &quot;abcd&quot;;
System.out.println(a == b);  // True
System.out.println(a.equals(b)); // True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>a==b为 true，因为 a 和 b 在方法区域中引用了相同的字符串。 内存引用是相同的。<br> 当多次创建同一字符串时，每个不同字符串值只存储一个副本。 这叫做“字符串主流”。 Java 中的所有编译时常量字符串都会自动实现。</p><p><strong>例子2</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>String c = new String(&quot;abcd&quot;);
String d = new String(&quot;abcd&quot;);
System.out.println(c == d);  // False
System.out.println(c.equals(d)); // True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>c == d是 false，因为 c 和 d 引用堆中的两个不同对象。 不同的对象总是有不同的内存引用。</p><p>下面这个图表说明了上述两种情况：<br><img src="`+m+'" alt="constructorvsdoublequotesJavaStringNewPage650x324.png" loading="lazy"><br><img src="'+h+'" alt="772dedd20f0443648fe19bf102c78efa.jpeg" loading="lazy"></p>',32),S={href:"https://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/",target:"_blank",rel:"noopener noreferrer"};function A(k,j){const i=n("ExternalLinkIcon");return d(),l("div",null,[_,c("more"),y,a("p",null,[e("它将抛出 "),a("a",f,[e("ConcurrentModificationException"),s(i)]),e("。"),q,e(" 使用迭代器进行删除能够避免这个问题，代码如下")]),L,a("p",null,[a("a",S,[e("原文链接"),s(i)])])])}const z=r(x,[["render",A],["__file","0.JAVA开发者常犯的10大错误译.html.vue"]]);export{z as default};

import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as i,f as c,a as e,e as t,d as r,b as l}from"./app-ef0b4d9d.js";const p="/assets/70-e4874a26.png",_="/assets/70-1663225834684-323-ba232ffa.png",g="/assets/70-1663225836463-326-367f64f4.png",d="/assets/70-1663225836463-326-367f64f4.png",m="/assets/70-1663225839996-332-f2e62bd2.png",h="/assets/77752ed5-e578f142.jpg",I="/assets/image-74267f60-d320e2c8.png",O="/assets/image-61602a6c-c30c4847.png",b="/assets/image-38734628-9e682657.png",f="/assets/image-22ea3f5a-f32583ce.png",u="/assets/image-f587a5bf-4196251f.png",y="/assets/image-42e9d62c-31803901.png",N={},z=e("h2",{id:"简介",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),t(" 简介")],-1),x=e("p",null,"Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端。Netty 是基于NIO 的通信框架，使用Reactor模式，它支持快速简单地开发网络应用程序，极大地简化了网络编程。下面介绍Netty设计模式及IO模型。",-1),R=l('<h2 id="i-o模型" tabindex="-1"><a class="header-anchor" href="#i-o模型" aria-hidden="true">#</a> I/O模型</h2><p>1、BIO(同步阻塞IO)<br><img src="'+p+'" alt="这里写图片描述" loading="lazy"></p><p>由图可知，BIO整个过程都是阻塞的，每开启一个新的请求都需要一个新的线程去执行，严重依赖于线程。线程是属于很贵的资源，线程的创建、销毁、上下文切换的成本都非常高。一般BIO适用于连接数不是很大的情况下（单机少于1000），编程实现较为简单。</p><p>2、非阻塞IO<br><img src="'+_+'" alt="这里写图片描述" loading="lazy"></p><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。非阻塞IO需要进程进行不断轮询，消耗资源。</p><p>3、IO复用模型（NIO）<br><img src="'+g+'" alt="这里写图片描述" loading="lazy"><br> 多个的进程的IO可以注册到一个复用器（select)上，然后用一个进程调用该select， select会监听所有注册进来的IO, 如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞,而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p><p>4、信号驱动式I/O（SIGIO）<br><img src="'+d+'" alt="这里写图片描述" loading="lazy"><br> 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p><p>5、异步I/O（java AIO）<br><img src="'+m+'" alt="这里写图片描述" loading="lazy"><br> 当进程发起一个IO操作，进程返回（不阻塞)，但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据</p><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h3><p><img src="'+h+'" alt="emma_1" loading="lazy"></p><p>前面四种都是同步IO，只有异步I/O是异步的<br><strong>注意点</strong><br> 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求等待数据准备是否会阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。<br> 同步需要主动读写数据,异步是不需要主动读写数据。<br> 同步IO和异步IO是针对用户应用程序和内核的交互。</p><h2 id="reactor模式-反应器设计模式" tabindex="-1"><a class="header-anchor" href="#reactor模式-反应器设计模式" aria-hidden="true">#</a> Reactor模式（反应器设计模式）</h2><p>Reactor模式（反应器设计模式），是一种基于事件驱动的设计模式，在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求 一般出现在高并发系统中，比如Netty，Redis等</p><p>实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：<br> （1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。<br> （2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</p><p><strong>单线程模型：</strong><br><img src="'+I+'" alt="image.png" loading="lazy"><br><img src="'+O+'" alt="image.png" loading="lazy"><br><img src="'+b+'" alt="image.png" loading="lazy"><br> 使用场景: 对应小业务则适合，编码简单；对于高负载、大并发的应用场景不适合，一个NIO线程处理太多请求，则负载过高，并且可能响应变慢，导致大量请求超时，而且万一线程挂了，则不可用了</p><p><strong>多线程模型：</strong><br><img src="'+f+'" alt="image.png" loading="lazy"><br><img src="'+u+'" alt="image.png" loading="lazy"></p><p><img src="'+y+'" alt="image.png" loading="lazy"></p><p>一般都采用多线程模型。</p>',18),k=e("br",null,null,-1),B={href:"https://github.com/netty/netty/issues/2515",target:"_blank",rel:"noopener noreferrer"},v=e("br",null,null,-1),V={href:"https://netty.io/",target:"_blank",rel:"noopener noreferrer"},E=e("br",null,null,-1),H={href:"https://img.hacpai.com/file/2019/11/nio-663fb3cd.zip",target:"_blank",rel:"noopener noreferrer"};function j(C,L){const a=n("ExternalLinkIcon");return o(),i("div",null,[z,x,c("more"),R,e("p",null,[t("参考链接："),k,e("a",B,[t("github"),r(a)]),v,e("a",V,[t("官方文档"),r(a)])]),e("p",null,[t("资料："),E,e("a",H,[t("nio.zip"),r(a)])])])}const G=s(N,[["render",j],["__file","1.Netty学习笔记一IO模型和Reactor设计模式.html.vue"]]);export{G as default};

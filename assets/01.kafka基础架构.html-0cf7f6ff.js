import{_ as a}from"./20220619171126-93b3d956.js";import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as o,b as t}from"./app-ef0b4d9d.js";const s="/assets/image-20220930141046569-b448d740.png",i="/assets/image-20220930141423790-7c3b0ccd.png",l="/assets/image-20220930151833136-a2d0dcfc.png",f={},n=t('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><p>一个基本的Kafka基本体系如下图所示：</p><p><img src="'+s+'" alt="image-20220930141046569" loading="lazy"></p><ul><li>Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</li><li>Consumer：消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。</li><li>Broker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的Kafka服务节点或Kafka服务实例。</li></ul><p>在Kafka中还有两个特别重要的概念—主题（Topic）与分区（Partition）。Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到Kafka集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。主题是一个逻辑上的概念，一个主题有多个分区，如下所示：</p><p><img src="'+i+'" alt="image-20220930141423790" loading="lazy"></p><h3 id="副本机制" tabindex="-1"><a class="header-anchor" href="#副本机制" aria-hidden="true">#</a> 副本机制</h3><p>Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。副本为主从关系**，leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。**副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。</p><p><img src="'+a+'" alt="" loading="lazy"></p><p>**分区中所有副本叫做AR。所有与leader副本保持一定程度同步的副本组成ISR。**与leader副本同步滞后过多的副本组成OSR。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader。</p><p><strong>LEO</strong>是Log End Offset的缩写，它标识当前日志文件中下一条待写入消息的offset，下图中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。</p><p><strong>HW是High Watermark的缩写，俗称高水位</strong>，它标识了一个特定的消息偏移量，消费者只能拉取到这个offset之前的消息。<strong>ISR集合中最小的LEO即为分区的HW</strong>。</p><p><img src="'+l+'" alt="image-20220930151833136" loading="lazy"></p>',13),c=[n];function d(p,_){return r(),o("div",null,c)}const h=e(f,[["render",d],["__file","01.kafka基础架构.html.vue"]]);export{h as default};

import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,b as l}from"./app-ef0b4d9d.js";const e={},i=l(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>数据复制的意义：</p><ul><li>横向扩展（Scale-Out）：指在多个从库之间进行读负载均衡，以提高读性能。所有数据变更在主库上执行，把之前在主库上的读负载剥离出来，以承载更多的写请求，另外，如果读负载越来越大，可以通过扩展从库来提高读性能</li><li>数据安全性：形成多个备份库，减少在极端场景丢失造成损失，对于主库来说，从库有多个，所以如果在从库上执行备份，对只读应用的可用性影响就要小很多（从库的复制机制本身也支持断点续传）。也就是说，在执行备份操作时，选择使用从库而不使用主库是一个更好的替代方案，这样可以尽量减少对主库性能以及数据安全性的影响</li><li>为其他数据源、异构系统提供实时数据</li><li>故障切换</li></ul><p>常用的复制模式有一主多从、MHA+多节点集群 MHA Manage、MHA node。</p><h2 id="搭建" tabindex="-1"><a class="header-anchor" href="#搭建" aria-hidden="true">#</a> 搭建</h2><ul><li><p>先搭建好两台Mysql，版本保持一致且内网可通信</p></li><li><p>在主节点执行，为slave申请同步账号，<code>192.168.159.131</code>为slave的ip</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">grant</span> <span class="token keyword">replication</span> slave <span class="token keyword">on</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">&#39;slave&#39;</span><span class="token variable">@&#39;192.168.159.131&#39;</span> identified <span class="token keyword">by</span> <span class="token string">&#39;123456&#39;</span><span class="token punctuation">;</span>
FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><ul><li><p>mysql的配置文件/etc/my.cnf，增加以下配置</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 开启binlog</span>
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">mysql-bin</span>
<span class="token key attr-name">server-id</span><span class="token punctuation">=</span><span class="token value attr-value">100</span>
<span class="token comment"># 需要同步的数据库，如果不配置则同步全部数据库</span>
<span class="token key attr-name">binlog-do-db</span><span class="token punctuation">=</span><span class="token value attr-value">xxx</span>
<span class="token comment"># binlog日志保留的天数，清除超过20天的日志</span>
<span class="token comment"># 防止日志文件过大，导致磁盘空间不足</span>
<span class="token key attr-name">expire-logs-days</span><span class="token punctuation">=</span><span class="token value attr-value">20 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重启master</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">service</span> mysql restart
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>slave配置：在/etc/my.cnf配置文件，增加以下配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>server-id<span class="token operator">=</span><span class="token number">101</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>进入到slave mysql后，再输入以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>CHANGE MASTER TO 
<span class="token assign-left variable">MASTER_HOST</span><span class="token operator">=</span><span class="token string">&#39;172.168.1.2&#39;</span>,//主机IP
<span class="token assign-left variable">MASTER_USER</span><span class="token operator">=</span><span class="token string">&#39;slave&#39;</span>,//之前创建的用户账号
<span class="token assign-left variable">MASTER_PASSWORD</span><span class="token operator">=</span><span class="token string">&#39;123456&#39;</span>,//之前创建的用户密码
<span class="token assign-left variable">MASTER_LOG_FILE</span><span class="token operator">=</span><span class="token string">&#39;mysql-bin.000001&#39;</span>,//master主机的binlog日志名称
<span class="token assign-left variable">MASTER_LOG_POS</span><span class="token operator">=</span><span class="token number">100</span>,//binlog日志偏移量
<span class="token assign-left variable">master_port</span><span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">;</span>//端口
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>启动slave服务</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>start slave;
show slave status;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>连接master主机节点，往主机节点创建表检验、插入数据，检查slave节点是否有master插入的数据</p></li></ul><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><p><img src="https://tuchuang-1254256192.cos.ap-nanjing.myqcloud.com/typora/20220629081417.png" alt="" loading="lazy"></p><ol><li>Master将数据改变记录写入到binlog文件中，Master binlog dump线程将二进制文件内容推送给slave库,除非是新建连接。</li><li>Slave通过I/O线程将Master推送的数据写入中继日志(relay log)，中继日志充当缓冲区。</li><li>Slave SQL线程将中继日志的数据执行，完成同步。</li></ol><h2 id="binlog复制模式" tabindex="-1"><a class="header-anchor" href="#binlog复制模式" aria-hidden="true">#</a> Binlog复制模式</h2><ul><li>基于row的复制模式 <ul><li>使用row格式的二进制日志时，主库会将产生的事件（一组事件）写入二进制日志，以事件来表示数据的变更。将这些表示数据变更的事件复制到从库，然后在从库中应用这些事件，把主库数据同步到从库，这称为基于row（行）的复制，简称为RBR</li><li>关键行为：将ROW变更转成Binlog二进制日志在从库重放</li></ul></li><li>基于statement的复制模式 <ul><li>使用statement格式的二进制日志时，主库会将SQL语句文本写入二进制日志。在主库上执行的SQL语句，然后将主库的SQL变更在从库重放，这称为基于statement（语句）的复制，简称为SBR</li><li>关键行为：SQL转成Binlog二进制日志在从库重放</li></ul></li><li>mixed复制模式 <ul><li>默认采用基于SQL的复制，一旦发现基于SQL的无法精确的复制时，就会采用基于行的复制</li></ul></li></ul><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h3><ul><li>row <ul><li>优势： <ul><li>可以正确复制所有数据的变更，这是最安全的复制格式</li></ul></li><li>劣势： <ul><li>生成更多的二进制日志数据，因为基于row的复制会将每行数据的变更都写入二进制日志。利用二进制日志进行备份和恢复的时间也会更长。此外，二进制日志的文件锁也会因为需要更长的时间来写入数据而被持有更久的时间，这可能会影响数据库的并发能</li><li>无法直接看到从库中执行的语句，但是可以使用mysqlbinlog工具</li></ul></li></ul></li><li>statement <ul><li>优势： <ul><li>写入日志文件的数据较少。当更新或删除操作涉及多行时，可以大大减少存储空间，在利用二进制日志备份与恢复数据时也可以快速完成。</li><li>日志文件中包含所有的数据变更的原始语句，可用于数据库审计。</li></ul></li><li>劣势： <ul><li>一些执行结果不确定的DML语句，不能使用基于statement的复制，否则可能会造成主从库的数据不一致</li><li>DML语句中，使用不带ORDER BY的LIMIT子句时，由于在主从库之间执行的排序结果可能不同，所以执行结果是不确定的</li><li>使用statement格式的日志时，一些内置的函数无法正确复制</li></ul></li></ul></li></ul><h3 id="gtid复制" tabindex="-1"><a class="header-anchor" href="#gtid复制" aria-hidden="true">#</a> GTID复制</h3><p>上述的复制模式中，复制拓扑的初始化配置和变更、复制的高可用切换等操作都需要找到正确的二进制日志文件和位置，否则就无法正确复制。GTID（Global Transaction Identifier，全局事务标识符），即基于GTID实现的复制，指的是基于事务的复制。</p><p>开启GTID复制：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">gtid_mode</span><span class="token operator">=</span>on    <span class="token punctuation">(</span>必选<span class="token punctuation">)</span>
enforce-gtid-consistency<span class="token operator">=</span><span class="token number">1</span>  （必选）
<span class="token assign-left variable">log_bin</span><span class="token operator">=</span>mysql-bin           （可选）    <span class="token comment">#高可用切换，最好开启该功能</span>
log-slave-updates<span class="token operator">=</span><span class="token number">1</span>     （可选）       <span class="token comment">#高可用切换，最好打开该功能</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>GTID工作原理 <ul><li>master更新数据时，会在事务前产生GTID，一同记录到binlog日志中</li><li>slave端的i/o 线程将变更的binlog，写入到本地的relay log中</li><li>sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录</li><li>如果有记录，说明该GTID的事务已经执行，slave会忽略</li><li>如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog</li><li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描</li></ul></li><li>GTID优势 <ul><li>一个事务对应一个唯一ID，一个GTID在一个服务器上只会执行一次;</li><li>GTID是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置;</li><li>减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主机;</li></ul></li><li>GTID的劣势 <ul><li>不支持非事务引擎;</li><li>不支持create table ... select 语句复制(主库直接报错);(原理: 会生成两个sql, 一个是DDL创建表SQL, 一个是insert into 插入数据的 sql; 由于DDL会导致自动提交, 所以这个sql至少需要两个GTID, 但是GTID模式下, 只能给这个sql生成一个GTID)</li><li>不允许一个SQL同时更新一个事务引擎表和非事务引擎表</li><li>在一个复制组中，必须要求统一开启GTID或者是关闭GTID</li></ul></li></ul>`,19),t=[i];function o(r,p){return a(),n("div",null,t)}const u=s(e,[["render",o],["__file","01.Mysql高可用.html.vue"]]);export{u as default};

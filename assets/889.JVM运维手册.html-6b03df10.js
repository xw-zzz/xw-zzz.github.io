import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c as d,a as n,e as a,d as i,b as e}from"./app-ef0b4d9d.js";const p="/assets/20220103111724-e8424fa3.png",c="/assets/20220103112245-09ca9230.png",o="/assets/20220103113317-7fee4c00.png",u="/assets/20220121200311-e5b26442.png",v="/assets/20220121200946-e2f53772.png",m="/assets/20220121201103-0f1b8b11.png",h="/assets/20220121225626-9922b7fb.png",b="/assets/20220121225822-382d1f6d.png",g="/assets/20220121172828-9f3e31f0.png",k="/assets/20220121173209-8e6a55bd.png",X="/assets/20220121173954-61545276.png",x="/assets/20220121174245-21b8e49b.png",f="/assets/20220103001309-6c5bc83d.png",C="/assets/20220103002808-95e3701a.png",j="/assets/20220103002857-b224d52e.png",M="/assets/20210308175912-e65eaae4.png",P="/assets/20210308221020-2d9fe9dc.png",_="/assets/20220106171757-c770dee8.png",G="/assets/20210308225201-b479fc79.png",y="/assets/20210308233608-de768b86.png",S="/assets/20210308225427-3f060a03.png",w="/assets/image-20210308232024256-45f80a81.png",D="/assets/image-20210308232142211-0772f8eb.png",z="/assets/20220116183944-74f7436d.png",J="/assets/20220116184728-be580043.png",O="/assets/20220116214815-1b2efaf7.png",T="/assets/20220118193907-e8492ea4.png",A="/assets/20220118192957-7ff114d2.png",I="/assets/20220118194455-dc7a0246.png",U="/assets/20220118195629-a8fade65.png",V={},E=e('<p>[TOC]</p><h1 id="_1-常见情况排查" tabindex="-1"><a class="header-anchor" href="#_1-常见情况排查" aria-hidden="true">#</a> 1.常见情况排查</h1><h2 id="_1-1-cpu占用过高定位" tabindex="-1"><a class="header-anchor" href="#_1-1-cpu占用过高定位" aria-hidden="true">#</a> 1.1 cpu占用过高定位</h2><p>首先使用top命令查看是哪个java进程占用CPU过高</p><p><img src="'+p+'" alt="" loading="lazy"></p><p>针对cpu占用高的进程查看具体线程占用情况，命令：<code>ps H -eo pid,tid,%cpu | grep 38816</code>，其中38816为pid，tid为线程id，%cpu为cpu使用率。</p><p><img src="'+c+`" alt="" loading="lazy"></p><p>发现线程38841占用比较高，将该线程ID转为十六进制，对应十六进制数为97B9,使用jstack命令查看线程具体信息，命令格式为</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 命令格式
jstack 进程ID |grep 线程ID -A 40

## 例子
jstack 38816 |grep 97b9 -A 40
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+`" alt="" loading="lazy"></p><p><strong>使用arthas分析：</strong></p><p>通过thread命令查看，命令为<code>thread -n 3</code>,查看前三个占用率最高的线程</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220103114224.png" alt="" loading="lazy"></p><ul><li><code>thread -n 3 -i 1000</code> : 列出1000ms内最忙的3个线程栈</li><li><code>thread -i 1000</code> : 统计最近1000ms内的线程CPU时间。</li></ul><p>cpu使用过高的一般原因有以下几点:</p><ul><li>程序计算比较密集</li><li>死循环</li><li>过多的线程</li><li>频繁的IO读写</li></ul><h2 id="_1-2-程序假死" tabindex="-1"><a class="header-anchor" href="#_1-2-程序假死" aria-hidden="true">#</a> 1.2 程序假死</h2><p>发生假死可能有以下几种情况:</p><ul><li>程序死锁</li><li>MajorGC/Full GC STW导致</li></ul><p>首先排查是不是程序内部死锁导致，使用<code>jps</code>查看进程id</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 查看Java进程</span>
jps
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>jstack </code>命令查看程序有无死锁</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 查看应用线程情况</span>
jstack pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有发生死锁，查看GC是否正常，</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 查看GC情况 pid 进程ID</span>
jstat <span class="token parameter variable">-gc</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-h</span> <span class="token number">5</span> <span class="token punctuation">{</span>pid<span class="token punctuation">}</span> <span class="token number">5000</span> <span class="token number">1000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过观察GC日志也可以查看gc和堆内存使用情况</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 开启GC日志打印 </span>
jinfo <span class="token parameter variable">-flag</span> +PrintGCDetails pid

<span class="token comment">## 打印加上时间戳信息</span>
jinfo <span class="token parameter variable">-flag</span> +PrintGCTimeStamps pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果发现GC时间明显异常，则大概率是由于MajorGC/Full GC导致STW引起应用假死，需要进一步分析频繁导致MajorGC/Full GC的原因，需要导出应用快照进行 分析定位，命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 导出快照，{path}为快照路径
jmap -dump:format=b,file={path} PID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>导出快照后，推荐使用MAT、JProfiler工具分析快照，找到导致频繁MajorGC/Full GC的原因。</p><p><strong>使用arthas分析</strong></p><p>查看有无死锁。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>thread -b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看堆内存和GC情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dashboard
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>打开GC日志</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>vmoption PrintGCDetails true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>导出快照</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 导出快照
heapdump {path}

##例子
heapdump /tmp/dump.hprof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**注意：**目前JDK自带命令和arthas只支持找出synchronized关键字阻塞住的线程， 如果是<code>java.util.concurrent.Lock</code>， 目前还不支持,需要进一步分析。</p><h2 id="_1-3-接口性能优化" tabindex="-1"><a class="header-anchor" href="#_1-3-接口性能优化" aria-hidden="true">#</a> 1.3 接口性能优化</h2><p>arthas trace命令能主动搜索指定方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 格式如下：</span>
 trace <span class="token punctuation">[</span>--exclude-class-pattern <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> <span class="token punctuation">[</span>-n <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--listenerId <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-p <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-E<span class="token punctuation">]</span> <span class="token punctuation">[</span>--skipJDKMethod <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-v<span class="token punctuation">]</span> class-pattern method-pattern <span class="token punctuation">[</span>condition-express<span class="token punctuation">]</span> 
 
<span class="token comment">##示例如下：</span>
 trace com.tiduyun.cmp.biz.schedule.resource.CloudVendorResourceSyncSchedule resyncResources  <span class="token parameter variable">-n</span> <span class="token number">5</span> <span class="token parameter variable">--skipJDKMethod</span> <span class="token boolean">false</span> 
 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据结果对耗时比较久的方法进行代码分析，若分析比较困难，可对耗时较久的方法继续trace跟踪，直至找到原因。</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220106164602.png" alt="" loading="lazy"></p><h2 id="_1-4-内存溢出-内存泄漏" tabindex="-1"><a class="header-anchor" href="#_1-4-内存溢出-内存泄漏" aria-hidden="true">#</a> 1.4 内存溢出&amp;内存泄漏</h2><p>一般导致导致内存溢出有以下几个原因,其中堆内存溢出和直接内存溢出是最常见到的：</p><ul><li>堆内存溢出</li><li>直接内存溢出</li><li>永久区（元空间）内存溢出</li><li>过多创建线程导致直接内存溢出</li></ul><p>首先使用top命令查看内存大致占用情况</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">top</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用jps查看Java进程id,查看GC信息</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 查看进程信息
jps

## 查看GC信息和堆内存使用情况 {pid}为进程ID
jstat -gc -t -h 5 {pid} 5000 1000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果堆内存占用和GC异常，大概率是由于堆内存溢出导致，可通过转存快照进一步分析：</p><ul><li><p>堆内存溢出自动导出快照</p><p>arthas:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 堆溢出自动导出快照开关</span>
vmoption HeapDumpOnOutOfMemoryError <span class="token boolean">true</span>
<span class="token comment">## 快照导出路径</span>
vmoption HeapDumpPath /tmp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自带命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 堆溢出自动导出快照开关</span>
jinfo <span class="token parameter variable">-flag</span> +HeapDumpOnOutOfMemoryError PID

<span class="token comment">## 快照导出路径</span>
jinfo <span class="token parameter variable">-flag</span> <span class="token assign-left variable">HeapDumpPath</span><span class="token operator">=</span>/tmp PID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>手动导出</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 自带命令行导出快照，{path}为快照路径
jmap -dump:format=b,file={path} PID

## arthas导出快照
heapdump {path}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>如果堆内存占用和GC无明显异常，通过HeapDumpOnOutOfMemoryError和HeapDumpPath参数也无法生成快照，可导出快照通过OQL语言查看<code>java.nio.DirectByteBuffer</code>对象个数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## 查询快照中DirectByteBuffer对象在线个数</span>
SELECT * FROM java.nio.DirectByteBuffer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以MAT为例：</p><p><img src="`+u+'" alt="" loading="lazy"></p><p>如果<code>java.nio.DirectByteBuffer</code>对象数量很多，说明有大量堆外内存申请且没有释放，可抽取部分对象查看引用关系，对有较多引用的对象看代码进一步排查。</p><p><img src="'+v+'" alt="" loading="lazy"></p><p><img src="'+m+`" alt="" loading="lazy"></p><p><strong>总结：</strong></p><ul><li>HeapDumpOnOutOfMemoryError和HeapDumpPath参数无法对堆外内存溢出生成快照。</li><li>一般堆外内存发生在使用NIO的程序中，Jvm通过<code>java.nio.DirectByteBuffer</code>对象保持对堆外内存引用，可通过分析堆中该对象数量判断堆外内存的申请情况，通过引用关系逐一排查可能存在堆外内存泄漏的点,可以通过在本地环境使用Visual VM、JProfiler等工具实时附加进一步验证分析。</li><li>内存泄漏的常见原因： <ul><li>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的<br> 引用而导致不能被回收。</li><li>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</li><li>各种连接，如数据库连接、网络连接和IO连接等。</li><li>改变Hash值。</li><li>缓存泄漏。</li><li>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</li></ul></li></ul><h2 id="_1-5-接口异常但没有输出日志-无法定位问题" tabindex="-1"><a class="header-anchor" href="#_1-5-接口异常但没有输出日志-无法定位问题" aria-hidden="true">#</a> 1.5 接口异常但没有输出日志，无法定位问题</h2><p>有些时候由于开发人员自身原因未将异常输出到日志，导致线上问题无法定位，可使用arthas的watch命名监听方法输出错误信息，格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## -n 监听次数 -x 监听方法层级</span>
<span class="token function">watch</span> 类名 方法名 <span class="token string">&#39;{params,returnObj,throwExp}&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span> 

<span class="token comment">## 例子</span>
<span class="token function">watch</span> com.tiduyun.cmp.flow.service.AuditProcessService addAuditProcess <span class="token string">&#39;{params,returnObj,throwExp}&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-6-应用链路分析" tabindex="-1"><a class="header-anchor" href="#_1-6-应用链路分析" aria-hidden="true">#</a> 1.6 应用链路分析</h2><p>使用arthas生成快照：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 查看支持的事件，常见的事件有  cpu、alloc、lock、wall、itimer
profiler list

## 生成快照信息 -d 200指定采样时间
profiler start --event cpu -f /var/log/cmp/%t.jfr -d 200
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用JProfiler打开快照：</p><p><img src="`+h+'" alt="" loading="lazy"></p><p>查看火焰图：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220121225731.png" alt="" loading="lazy"></p><p>查找指定类分析</p><p><img src="'+b+`" alt="" loading="lazy"></p><p><strong>该方法适合JProfiler无法直接附加分析的场景，如果JProfiler可以直接远程连接应用，直接附加即可。</strong></p><h1 id="_2-案例" tabindex="-1"><a class="header-anchor" href="#_2-案例" aria-hidden="true">#</a> 2. 案例</h1><h2 id="_2-1-cmp-job假死排查" tabindex="-1"><a class="header-anchor" href="#_2-1-cmp-job假死排查" aria-hidden="true">#</a> 2.1 cmp-job假死排查</h2><p>现象：在线上环境发现该服务经常隔两天就崩溃，注册不上xxl-job，服务部分时间没响应。</p><p>分析过程：</p><p>使用arthas附加上去，使用<code>dashboard</code>命令查看面板数据，发现当前内存占用正常，但GC的时间明显异常，结合job服务的业务场景，主要是执行定时任务，推测是某个定时任务导致OOM, 于是加了OOM自动导出快照参数,当程序发生OOM时自动保存快照。</p><p>arthas:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>
<span class="token comment">## 堆溢出自动导出快照</span>
vmoption HeapDumpOnOutOfMemoryError <span class="token boolean">true</span>
<span class="token comment">## 快照导出路径</span>
vmoption HeapDumpPath /tmp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导出快照后使用MAT工具分析，查看内存泄漏报告</p><p><img src="`+g+'" alt="" loading="lazy"></p><p>发现<code>CloudResourceStatisticalReportServiceImpl.lambda$screenResourceType</code>处占用了大量的内存，初步怀疑是这个地方发生了内存溢出，进一步查看直方图，发现存在大量的<code>com.tiduyun.cmp.common.model.assessment.CloudResourceStatisticalReport</code>对象</p><p><img src="'+k+'" alt="" loading="lazy"></p><p>进一步查看支配树，发现某个线程创建了大量的<code>com.tiduyun.cmp.common.model.assessment.CloudResourceStatisticalReport</code>对象，占用的深堆很大。</p><p><img src="'+X+'" alt="" loading="lazy"></p><p>进一步查看该线程，可看到该线程的异常信息，是由于某个定时任务执行导致内存溢出。</p><p><img src="'+x+`" alt="" loading="lazy"></p><p>进一步分析代码是由于程序将数据库所有的数据一次性查出来生成报表的过程中，因为数据量太大从而导致内存溢出，后通过将该任务进行分片分配到多个节点执行解决了该问题。</p><h1 id="附录1-jvm运行时参数" tabindex="-1"><a class="header-anchor" href="#附录1-jvm运行时参数" aria-hidden="true">#</a> 附录1. JVM运行时参数</h1><h2 id="jvm参数类型" tabindex="-1"><a class="header-anchor" href="#jvm参数类型" aria-hidden="true">#</a> JVM参数类型</h2><p>JVM参数分为三种标准参数、-X型参数和-XX型参数。</p><h3 id="标准参数选项" tabindex="-1"><a class="header-anchor" href="#标准参数选项" aria-hidden="true">#</a> 标准参数选项</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\Users\\xw&gt;java -help
用法: java [-options] class [args...]
           (执行类)
   或  java [-options] -jar jarfile [args...]
           (执行 jar 文件)
其中选项包括:
    -d32          使用 32 位数据模型 (如果可用)
    -d64          使用 64 位数据模型 (如果可用)
    -server       选择 &quot;server&quot; VM
                  默认 VM 是 server.

    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;
    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;
                  用 ; 分隔的目录, JAR 档案
                  和 ZIP 档案列表, 用于搜索类文件。
    -D&lt;名称&gt;=&lt;值&gt;
                  设置系统属性
    -verbose:[class|gc|jni]
                  启用详细输出
    -version      输出产品版本并退出
    -version:&lt;值&gt;
                  警告: 此功能已过时, 将在
                  未来发行版中删除。
                  需要指定的版本才能运行
    -showversion  输出产品版本并继续
    -jre-restrict-search | -no-jre-restrict-search
                  警告: 此功能已过时, 将在
                  未来发行版中删除。
                  在版本搜索中包括/排除用户专用 JRE
    -? -help      输出此帮助消息
    -X            输出非标准选项的帮助
    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]
    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]
                  按指定的粒度启用断言
    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]
    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]
                  禁用具有指定粒度的断言
    -esa | -enablesystemassertions
                  启用系统断言
    -dsa | -disablesystemassertions
                  禁用系统断言
    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]
                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof
                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help
    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]
                  按完整路径名加载本机代理库
    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]
                  加载 Java 编程语言代理, 请参阅 java.lang.instrument
    -splash:&lt;imagepath&gt;
                  使用指定的图像显示启动屏幕
有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="x参数选项" tabindex="-1"><a class="header-anchor" href="#x参数选项" aria-hidden="true">#</a> X参数选项</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\Users\\xw&gt;java -X
    -Xmixed           混合模式执行 (默认)
    -Xint             仅解释模式执行
    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;
                      设置搜索路径以引导类和资源
    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;
                      附加在引导类路径末尾
    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;
                      置于引导类路径之前
    -Xdiag            显示附加诊断消息
    -Xnoclassgc       禁用类垃圾收集
    -Xincgc           启用增量垃圾收集
    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)
    -Xbatch           禁用后台编译
    -Xms&lt;size&gt;        设置初始 Java 堆大小
    -Xmx&lt;size&gt;        设置最大 Java 堆大小
    -Xss&lt;size&gt;        设置 Java 线程堆栈大小
    -Xprof            输出 cpu 配置文件数据
    -Xfuture          启用最严格的检查, 预期将来的默认值
    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)
    -Xcheck:jni       对 JNI 函数执行其他检查
    -Xshare:off       不尝试使用共享类数据
    -Xshare:auto      在可能的情况下使用共享类数据 (默认)
    -Xshare:on        要求使用共享类数据, 否则将失败。
    -XshowSettings    显示所有设置并继续
    -XshowSettings:all
                      显示所有设置并继续
    -XshowSettings:vm 显示所有与 vm 相关的设置并继续
    -XshowSettings:properties
                      显示所有属性设置并继续
    -XshowSettings:locale
                      显示所有与区域设置相关的设置并继续


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>-X 选项是非标准选项, 如有更改, 不另行通知。</strong></p><h3 id="xx参数选项" tabindex="-1"><a class="header-anchor" href="#xx参数选项" aria-hidden="true">#</a> XX参数选项</h3><p>分类：分为boolean类型和非boolean类型。boolean类型格式为<code>-XX:+&lt;option&gt;</code>表示启用。<code>-XX:-&lt;option&gt;</code>表示禁用，非boolean类型格式<code>-XX:&lt;option&gt;=&lt;number&gt;</code>或者<code>-XX:&lt;option&gt;=&lt;string&gt;</code>。</p><h2 id="常用的jvm参数选项" tabindex="-1"><a class="header-anchor" href="#常用的jvm参数选项" aria-hidden="true">#</a> 常用的JVM参数选项</h2><h3 id="打印设置的xx选项及值" tabindex="-1"><a class="header-anchor" href="#打印设置的xx选项及值" aria-hidden="true">#</a> 打印设置的XX选项及值</h3><ul><li>-XX:+PrintCommandLineFlags ，可以在程序运行前打印出用户手动设置或者JVM自动设置的XX选项</li><li>-XX:+PrintFlagsInitial,打印出所有XX选项的默认值</li><li>-XX:+PrintFlagsFinal,打印出XX选项在运行程序时生效的值</li><li>-XX:+PrinitVMOptions,打印JVM的参数</li></ul><h3 id="堆栈参数设置" tabindex="-1"><a class="header-anchor" href="#堆栈参数设置" aria-hidden="true">#</a> 堆栈参数设置</h3><h4 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h4><ul><li>-Xss128k,设置每个线程的栈大小为128K</li></ul><h4 id="堆内存" tabindex="-1"><a class="header-anchor" href="#堆内存" aria-hidden="true">#</a> 堆内存</h4><ul><li>-Xms3550m,设置JVM初始堆内存为3550m</li><li>-Xmx3550m,设置JVM最大堆内存为3550m</li><li>-Xmn2g,设置年轻代大小为2g，等价于-XX:NewSize=2g -XX:MaxNewSize=2g，也就是设置年轻代初始值和年轻代最大值都是2G，官方推荐配置为整个堆大小的3/8</li><li>-XX:NewSize=1024m,设置年轻代初始值为1024M</li><li>-XX:MaxNewSize=1024m,设置年轻代最大值为1024M</li><li>-XX:SurvivorRatio=8,设置年轻代中Eden区与一个Survivor区的比值，默认为8</li><li>-XX:+UseAdaptiveSizePolicy,自动选择各区大小比例。默认开启，将会导致Eden区和Survivor区的比例自动分配，因此也会引起我们默认值-XX:SurvivorRatio=8失效</li><li>-XX:NewRatio=4,设置老年代与年轻代（包括1个Eden区和2个Survivor区）的比值，默认为2。根据实际情况进行设置，主要根据对象生命周期来进行分配，如果对象生命周期很长，那么让老年代大一点，否则让新生代大一点</li><li>-XX:PretenureSizeThreadshold=1024，设置让大于此阈值的对象直接分配在老年代，单位为字节，只对Serial、ParNew收集器有效。</li><li>-XX:MaxTenuringThreshold=15，默认值为15，新生代每次MinorGc后的年龄+1，当对象年龄大于15时进入老年代。</li><li>-XX:+PrintTenuringDistribution，让JVM每次MonitorGc时打印当前使用Survivor中对象的年龄分布。</li><li>-XX:TargetSurvivorRatio，表示MinorGc结束后Survivor区域中占用空间的期望比例。</li></ul><h4 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h4><ul><li>-XX:PermSize=256m，设置永久代初始值为256M</li><li>-XX:MaxPermSize=256m，设置永久代最大值为256M</li><li>-XX:MetaspaceSize，设置元空间初始大小</li><li>-XX:MaxMetaspaceSize，元空间最大值，默认没有限制</li><li>-XX:+UseCompressedOops，使用压缩对象指针</li><li>-XX:+UseCompressedClassPointers，使用压缩类指针</li><li>-XX:CompressedClassSpaceSize，设置Klass Metaspace的大小，默认1G</li></ul><h4 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存" aria-hidden="true">#</a> 直接内存</h4><ul><li>-XX:MaxDirectMemorySize，指定DirectMemory容量，若未指定，则默认与Java堆最大值一样</li></ul><h4 id="outofmemory相关选项" tabindex="-1"><a class="header-anchor" href="#outofmemory相关选项" aria-hidden="true">#</a> OutOfMemory相关选项</h4><ul><li>-XX:+HeapDumpOnOutOfMemoryError，表示在内存出现OOM的时候，生成Heap转储文件，以便后续分析，-XX:+HeapDumpBeforeFullGC和-XX:+HeapDumpOnOutMemoryError只能设置1个。</li><li>-XX:+HeapDumpBeforeFullGC，表示在出现FullGC之前，生成Heap转储文件，以便后续分析，-XX:+HeapDumpBeforeFullGC和-XX:+HeapDumpOnOutMemoryError只能设置1个，请注意FullGC可能出现多次，那么dump文件也会生成多个</li><li>-XX:HeapDumpPath=<code>&lt;path&gt;</code>，指定heap转存文件的存储路径，如果不指定，就会将dump文件放在当前目录中</li><li>-XX:OnOutOfMemoryError，指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</li></ul><h3 id="垃圾回收器相关选项" tabindex="-1"><a class="header-anchor" href="#垃圾回收器相关选项" aria-hidden="true">#</a> 垃圾回收器相关选项</h3><h4 id="查看默认的垃圾回收器" tabindex="-1"><a class="header-anchor" href="#查看默认的垃圾回收器" aria-hidden="true">#</a> 查看默认的垃圾回收器</h4><ul><li>-XX:+PrintCommandLineFlags,查看命令行相关参数</li></ul><h4 id="serial回收器" tabindex="-1"><a class="header-anchor" href="#serial回收器" aria-hidden="true">#</a> Serial回收器</h4><ul><li>-XX:+UseSerialGC,指定年轻代和老年大都使用串行收集器。等价于新生代用Serial GC,老年代用Serial Old GC</li></ul><h4 id="parnew回收器" tabindex="-1"><a class="header-anchor" href="#parnew回收器" aria-hidden="true">#</a> Parnew回收器</h4><ul><li>-XX:+UseParNewGC,手动指定使用ParNew收集器进行内存回收任务，年轻代使用并行收集器，不影响老年代。</li><li>-XX:+ParalleGCThreads,设置年轻代并行收集器的线程数，一般最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li></ul><h4 id="parallel回收器" tabindex="-1"><a class="header-anchor" href="#parallel回收器" aria-hidden="true">#</a> Parallel回收器</h4><ul><li>-XX:+UseParallelGC,手动指定年轻代使用Parallel并行收集器执行内存回收任务。-XX:+UseParallelOldGC,手动指定老年代都是使用并行回收收集器。上面这两个参数只要开启一个，两个同时生效。</li><li>-XX: ParallelGCThreads,设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。·在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]/8] 。</li><li>-XX:MaxGCPauseMillis,设置垃圾收集器最大停顿时间(即STw的时间)。单位是毫秒。为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</li><li>-XX:GCTimeRatio垃圾收集时间占总时间的比例(= 1/ (N + 1))。用于衡量吞吐量的大小。·取值范围（0,100）,默认值99，也就是垃圾回收时间不超过1%。·与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li><li>-XX:+UseAdaptiveSizePolicy,设置Parallel Scavenge收集器具有自适应调节策略。在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。·在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间(MaxGCPauseMills)，让虚拟机自己完成调优工作。</li></ul><p><strong>注意：</strong></p><ul><li>Parallel回收器主打吞吐量，而CMS和G1主打低延迟，如果主打吞吐量，那么就不应该限制最大停顿时间，所以-XX:MaxGCPauseMills不应该设置</li><li>-XX:MaxGCPauseMills中的调整堆大小通过默认开启的-XX:+UseAdaptiveSizePolicy来实现</li><li>-XX:GCTimeRatio用来衡量吞吐量，并且和-XX:MaxGCPauseMills矛盾，因此不会同时使用</li></ul><h4 id="cms回收器" tabindex="-1"><a class="header-anchor" href="#cms回收器" aria-hidden="true">#</a> CMS回收器</h4><ul><li>-XX:+UseConcMarkSweepGC,手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将-XX:+UseParNewGC打开。即:ParNew(Young区用)+CNS(01d区用)+Serial old的组合。<br> 开启该参数后会自动将-XX：+UseParNewGC打开.即：ParNew(Young区用)+CMS(Old区用)+Serial old的组合。</li><li>-XX:CMSInitiatingOccupanyFraction,设置堆内存使用率的阀值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CNS回收。JDK6及以上版本默认值为92%，·如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li><li>-XX:+UseCMSCompactAtFullcollection,用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li>-XX:CMSFullGcsBeforeCompaction,设置在执行多少次Full GC后对内存空间进行压缩整理。</li><li>-XX: ParallelCMSThreads,设置CMS的线程数量。 CMS 默认启动的线程数是(ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧胀时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li><li>-XX:ConcGCThreads:设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreadsi计算出来的</li><li>-XX:+UseCMSInitiating0ccupancyOnly:是否动态可调，用这个参数可以使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</li><li>-XX:+CMSScavengeBeforeRemark:强制hotspot虚拟机在cms remark阶段之前做一次minorgc，用于提高remark阶段的速度</li><li>-XX:+CMSClassUnloadingEnable:如果有的话，启用回收Perm区(JDK8之前)</li><li>-XX:+CMSParallelInitialEnabled:用于开启CMS initial-mark阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启:</li><li>-XX:+CMSParallelRemarkEnabled:用户开启CNS remark阶段采用多线程的方式进行重新标记，默认开启。</li><li>-XX:+ExplicitGCInvokesConcurrentAndUnloadsclasses这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期;</li><li>-XX:+CMSPrecleaningEnabled:指定CNS是否需要进行Pre cleaning这个阶段。</li></ul><p><strong>CMS在JDK9标记为Deprecate,在JDK14中被移除了。</strong></p><h4 id="g1回收器" tabindex="-1"><a class="header-anchor" href="#g1回收器" aria-hidden="true">#</a> G1回收器</h4><ul><li>-XX:+UseG1GC，手动指定使用G1收集器执行内存回收任务。</li><li>-XX:G1HeapRegionSize，设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMi1lis，设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</li><li>-XX:ParallelGCThread，设置STW时GC线程数的值。最多设置为8</li><li>-XX:ConcGCThreads，设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。</li><li>-XX:InitiatingHeap0ccupancyPercent，设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发Gc。默认值是45。</li><li>-XX:G1NewSizePercent、-XX:G1MaxNewSizePercent，新生代占用整个堆内存的最小百分比（默认5%）、最大百分比（默认60%）</li><li>-XX:G1ReservePercent=10，保留内存区域,防止 to space ( Survivor中的to区）溢出。</li></ul><p><strong>如果使用G1垃圾收集器，不建议设置-Xmn和-XX:NewRatio，毕竟可能影响G1的自动调节</strong></p><h3 id="gc日志相关" tabindex="-1"><a class="header-anchor" href="#gc日志相关" aria-hidden="true">#</a> GC日志相关</h3><ul><li><p>-verbose:gc，输出日志信息，默认输出的标准输出,格式如下：</p><p><img src="`+f+'" alt="" loading="lazy"></p></li><li><p>-XX:+PrintGC，等同于-verbose:gc表示打开简化的日志</p></li><li><p>-XX:+PrintGCDetails，在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域的分配情况，格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220103001349.png" alt="" loading="lazy"></p></li><li><p>-XX:+PrintGCTimeStamps，程序启动到GC发生的时间秒数，不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p>-XX:+PrintGCDateStamps，输出GC发生时的时间戳（以日期的形式，例如：2013-05-04T21:53:59.234+0800），不可以独立使用，可以配合-XX:+PrintGCDetails使用</p></li><li><p>-XX:+PrintHeapAtGC，每一次GC前和GC后，都打印堆信息</p></li><li><p>-XIoggc:<code>&lt;file&gt;</code>，把GC日志写入到一个文件中去，而不是打印到标准输出中</p></li><li><p>-XX:TraceClassLoading，监控类的加载</p></li><li><p>-XX:PrintGCApplicationStoppedTime，打印GC时线程的停顿时间</p></li><li><p>-XX:+PrintGCApplicationConcurrentTime，垃圾收集之前打印出应用未中断的执行时间</p></li><li><p>-XX:+PrintReferenceGC，记录回收了多少种不同引用类型的引用</p></li><li><p>-XX:+PrintTenuringDistribution，让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</p></li><li><p>-XX:+UseGCLogFileRotation，启用GC日志文件的自动转储</p></li><li><p>-XX:NumberOfGCLogFiles=1，GC日志文件的循环数目</p></li><li><p>-XX:GCLogFileSize=1M，控制GC日志文件的大小</p></li></ul><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><ul><li>-XX:+DisableExplicitGC，禁用hotspot执行System.gc()，默认禁用</li><li>-XX:ReservedCodeCacheSize=<code>&lt;n&gt;</code>[g|m|k]、-XX:InitialCodeCacheSize=<code>&lt;n&gt;</code>[g|m|k]，指定代码缓存的大小</li><li>-XX:+UseCodeCacheFlushing，使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</li><li>-XX:+DoEscapeAnalysis，开启逃逸分析</li><li>-XX:+UseBiasedLocking，开启偏向锁</li><li>-XX:+UseLargePages，开启使用大页面</li><li>-XX:+PrintTLAB，打印TLAB的使用情况</li><li>-XX:TLABSize，设置TLAB大小</li></ul><h2 id="添加jvm参数选项" tabindex="-1"><a class="header-anchor" href="#添加jvm参数选项" aria-hidden="true">#</a> 添加JVM参数选项</h2><h3 id="idea" tabindex="-1"><a class="header-anchor" href="#idea" aria-hidden="true">#</a> IDEA</h3><p><img src="'+C+'" alt="" loading="lazy"></p><p><img src="'+j+`" alt="" loading="lazy"></p><h3 id="运行时" tabindex="-1"><a class="header-anchor" href="#运行时" aria-hidden="true">#</a> 运行时</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 设置非Boolean类型参数
jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;

## 设置Boolean类型参数
jinfo -flag [+][-] &lt;name&gt; &lt;pid&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="jar包" tabindex="-1"><a class="header-anchor" href="#jar包" aria-hidden="true">#</a> jar包</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -xms20m jar demo.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="tomcat" tabindex="-1"><a class="header-anchor" href="#tomcat" aria-hidden="true">#</a> Tomcat</h3><ul><li>Linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：JAVA_OPTS=&quot;-Xms512M -Xmx1024M&quot;</li><li>Windows系统下载catalina.bat中添加类似如下配置：set &quot;JAVA_OPTS=-Xms512M -Xmx1024M&quot;</li></ul><h3 id="程序运行时" tabindex="-1"><a class="header-anchor" href="#程序运行时" aria-hidden="true">#</a> 程序运行时</h3><ul><li><p>使用<code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code>设置非Boolean类型参数</p></li><li><p>使用<code>jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</code>设置Boolean类型参数</p><p><strong>使用arthas</strong>:</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>vmoption <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
如
vmoption PrintGC <span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="附录2-jvm监控及诊断工具" tabindex="-1"><a class="header-anchor" href="#附录2-jvm监控及诊断工具" aria-hidden="true">#</a> 附录2.JVM监控及诊断工具</h1><h2 id="命令行篇" tabindex="-1"><a class="header-anchor" href="#命令行篇" aria-hidden="true">#</a> 命令行篇</h2><h3 id="jps" tabindex="-1"><a class="header-anchor" href="#jps" aria-hidden="true">#</a> jps</h3><p>作用：查看增在运行的java进程</p><p>参数：</p><ul><li>-q :仅仅显示LVMID(local virtual machine id),即本地虚拟机唯一ID，不显示类名称</li><li>-l: 输出应用程序主类的全类名</li><li>-v: 列出虚拟机进程启动时的JVM参数</li><li>-m 输出虚拟机进程启动传给主类main()的参数</li></ul><h3 id="jstat" tabindex="-1"><a class="header-anchor" href="#jstat" aria-hidden="true">#</a> jstat</h3><p>作用：查看JVM统计信息,常应用于检测垃圾回收问题和OOM。</p><p>命令格式为:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-t : 显示程序的运行时间，单位为秒。</li><li>interval: 指定输出统计数据的周期，单位为毫秒。</li><li>count: 用于指定统计的总次数</li><li>-h: 每隔多少行输出表头数据</li><li>vmid: 进程id(通过jps命令获取)</li></ul><p>option选项：</p><ul><li><p>-class: 显示classloader相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间</p></li><li><p>-gc: 显示gc相关的堆信息</p></li><li><p>-gccapacity: 输出信息主要与gc相同，但输出主要关注堆各个区域用到的最小和最大空间</p></li><li><p>-gcutil: 显示内容与gc基本相同，主要关注百分比</p></li><li><p>-gccause: 与gcutil功能一样，但会输出最后一次gc的原因</p></li><li><p>-gcnew: 显示新生代GC状况</p></li></ul><p>示例如下图:</p><p><img src="`+M+`" alt="" loading="lazy"></p><ul><li>SOC: 第一个幸存区大小，单位为字节</li><li>S1C: 第二次幸存区大小，单位为字节</li><li>S0U: 第一个幸存区已使用的大小，单位为字节</li><li>S1U: 第二个幸存区已使用的大小，单位为字节</li><li>EC: Eden空间的大小</li><li>EU: Eden已使用空间的大小</li><li>OC: 老年代的大小</li><li>OU：老年代已使用的大小</li><li>MC: 方法区的大小</li><li>MU: 方法区已使用的大小</li><li>CCSC: 压缩类空间的大小</li><li>CCSU: 压缩类已使用空间的大小</li><li>YGC: young gc次数</li><li>YGCT: yong gc消耗的时间</li><li>FGC: full gc次数</li><li>PGCT: full gc时间</li><li>GCT: 应用程序启动到采样gc总时间</li></ul><h3 id="jinfo" tabindex="-1"><a class="header-anchor" href="#jinfo" aria-hidden="true">#</a> jinfo</h3><p>作用： 查看和修改JVM配置信息</p><p>命令格式为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jinfo [option] &lt;pid&gt;
       
jinfo [option] &lt;executable &lt;core&gt;
      
jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;

#查看
jinfo -sysprops PID #查看由System.getProperties()取得的参数

jinfo -flags PID  #查看曾经赋值得一些参数

jinfo -flag 具体参数 PID #查看某个java进程的具体参数的值


#修改
jinfo -flag [+|-]具体参数 PID  ## boolean类型修改

jinfo -flag 具体参数=参数值 PID ##非boolean类型


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+P+'" alt="" loading="lazy"></p><p><strong>只有标记为manageable的flag才可以被实时修改</strong>，查看manageable参数命令为 <code>java -XX:+PrintFlagsFinal -version| grep manageable</code></p><p><img src="'+_+`" alt="" loading="lazy"></p><h3 id="jmap" tabindex="-1"><a class="header-anchor" href="#jmap" aria-hidden="true">#</a> jmap</h3><p>作用：dump文件和获取堆内存使用情况</p><p>命令格式 ：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jmap [option] &lt;pid&gt;

jmap [option] &lt;executable &lt;core&gt;

jmap [option] [server_id@]&lt;remote server IP or hostname&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常用命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1.手动导出内存映像文件  
# format =b表面格式与hprof对应起来，表面这是一个标准的格式
jmap -dump:format=b,file=d:\\1.hprof PID

## live 只保存堆中存活的对象
jmap -dump:live,format=b,file=d:\\1.hprof PID

2.OOM自动生成内存镜像文件
设置JVM参数；
-XX : +HeapDumpOnOutOfMemoryError:在程序发生00M时，导出应用程序的当前堆快照。
-XX:HeapDumpPath:可以指定堆快照的保存位置。

3.显示堆内存相关信息
jmap -heap PID &gt;1.txt

jmap -histo PID&gt;2.txt

4.查看系统的ClassLoader信息
jmap -permstat pid

5.查看堆积在finalizer队列中的对象
jmap -finalizerinfo 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</strong></p><p>实例如下图：</p><p><img src="`+G+'" alt="" loading="lazy"></p><h3 id="jhat" tabindex="-1"><a class="header-anchor" href="#jhat" aria-hidden="true">#</a> jhat</h3>',183),B={href:"http://localhost:7000/%E3%80%82",target:"_blank",rel:"noopener noreferrer"},F=e(`<p>命令格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jhat filePath
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例如下：</p><p><img src="`+y+'" alt="" loading="lazy"></p>',4),H={href:"http://localhost:7000",target:"_blank",rel:"noopener noreferrer"},R=e('<p><img src="'+S+`" alt="" loading="lazy"></p><h3 id="jstack" tabindex="-1"><a class="header-anchor" href="#jstack" aria-hidden="true">#</a> jstack</h3><p>作用:用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p>命令格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> jstack [-l] &lt;pid&gt;
 jstack -F [-m] [-l] &lt;pid&gt;
 jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;
 jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>option参数</p><ul><li>-F :当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l : 除堆栈外，显示关于锁的附加信息入</li><li>-m: 如果调用到本地方法的话，可以显示C/C++的堆栈</li><li>-h: 帮助操作</li></ul><h3 id="jcmd" tabindex="-1"><a class="header-anchor" href="#jcmd" aria-hidden="true">#</a> jcmd</h3><p>作用：它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如:用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等,官方推荐使用jcmd代替其他命令。</p><p>常用命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1.列出所有JVM进程
jcmd -l 

2.查看指定PID支持的操作
jcmd PID help 

3.jcmd操作
jcmd PID 支持的操作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例演示：</p><p><img src="`+w+'" alt="" loading="lazy"></p><p>使用jcmd导出dump:</p><p><img src="'+D+'" alt="" loading="lazy"></p><h2 id="gui工具" tabindex="-1"><a class="header-anchor" href="#gui工具" aria-hidden="true">#</a> GUI工具</h2><p>推荐使用MAT、Jprofiler进行离线分析，推荐使用Jprofiler、Arthas在线分析诊断。</p><h3 id="arthas" tabindex="-1"><a class="header-anchor" href="#arthas" aria-hidden="true">#</a> Arthas</h3><p><code>Arthas</code> 是Alibaba开源的Java诊断工具,功能十分强大，常见命令如下：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/ArtHas.png" alt="" loading="lazy"></p>',20),N={href:"https://arthas.aliyun.com/doc/commands.html",target:"_blank",rel:"noopener noreferrer"},L=e(`<p>常见的arthas特殊用法：</p><ul><li><p>watch/monitor/trace 重载方法过滤</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">hello</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;yangliu&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">hello</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">hello</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">User</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>监听<code>arthas.Test#hello(arthas.User)</code>方法,通过参数类型去区分。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">watch</span> arthas.Test hello <span class="token string">&#39;{params,returnObj,throwExp}&#39;</span> <span class="token string">&#39;params[0].class.name==&quot;arthas.User&quot;&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>监听<code>arthas.Test#hello(java.lang.String)</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">watch</span> arthas.Test hello <span class="token string">&#39;{params,returnObj,throwExp}&#39;</span> <span class="token string">&#39;params[0].class.name==&quot;java.lang.String&quot;&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过参数个数区分</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">watch</span> arthas.Test hello <span class="token string">&#39;{params,returnObj,throwExp}&#39;</span> <span class="token string">&#39;params.length==2&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>watch方法过滤</p><ul><li><p>查看第一个参数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">watch</span> arthas.Test hello <span class="token string">&#39;{params[0],returnObj,throwExp}&#39;</span> <span class="token string">&#39;params.length==2&#39;</span>  <span class="token parameter variable">-n</span> <span class="token number">5</span>  <span class="token parameter variable">-x</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>只监听指定参数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> watch arthas.Test hello &#39;{params,returnObj,throwExp}&#39; &#39;params.length==2 &amp;&amp; params[0]==255&#39;  -n 5  -x 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>只查看list参数某个属性</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>watch arthas.Test printUsers &#39;{params[0].{#this.age},returnObj,throwExp}&#39;   -n 5  -x 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>对list条件过滤，如对age进行过滤</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>watch arthas.Test printUsers &#39;{params,returnObj,throwExp}&#39; &#39;params[0].{? #this.age==1}&#39; -n 5  -x 3 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul></li><li><p>watch指定调用栈</p></li></ul><p>​</p><h3 id="mat-memory-analyzer" tabindex="-1"><a class="header-anchor" href="#mat-memory-analyzer" aria-hidden="true">#</a> MAT（Memory Analyzer）</h3><p>MAT是一款功能强大的Java堆内存分析器，一般用于查找内存泄漏和内存使用情况，推荐使用该工具进行堆内存分析，主页图如下。</p><p><img src="`+z+'" alt="" loading="lazy"></p><p>查看线程内存使用情况：</p><p><img src="'+J+'" alt="" loading="lazy"></p><p>常使用的菜单导航：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220116203736.png" alt="" loading="lazy"></p><p>支配树查看：</p><p><img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220116205406.png" alt="" loading="lazy"></p><p>相关概念：</p><ul><li><p>浅堆（Shallow Heap）：是指一个对象本身占用的内存,不包括其内部引用对象的大小。</p></li><li><p>保留集：对象A的保留集为只能通过对象A直接或间接访问到的所有对象的集合。</p></li><li><p>深堆（Retained Heap）: 对象的保留集中所有对象的浅堆大小之和。</p></li><li><p>支配树：支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p><ul><li><p>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</p></li><li><p>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</p></li><li><p>支配树的边与对象引用图的边不直接对应。</p><p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于<br> 在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象<br> D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象<br> D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，<br> 所以，对象D的直接支配者为对象C。</p></li></ul></li></ul><p>​ <img src="https://cdn.jsdelivr.net/gh/2457081614/blog-image/20220116205243.png" alt="" loading="lazy"></p><h3 id="jprofiler" tabindex="-1"><a class="header-anchor" href="#jprofiler" aria-hidden="true">#</a> JProfiler</h3><p>JProfiler是一款Java应用性能诊断工具，功能强大，相对于MAT来说在线分析功能更加强大，但是收费,具有以下特点：</p><ul><li>使用方便、界面操作友好</li><li>对被分析的应用影响小</li><li>CPU,Thread,Memory分析功能尤其强大</li><li>支持对jdbc,noSq1,jsp, servlet,socket等进行分析</li><li>支持多种模式(离线，在线)的分析</li><li>支持监控本地、远程的JVM</li><li>跨平台,拥有多种操作系统的安装版本</li></ul><p>离线分析：</p><p>离线分析快照,只能使用堆遍历器菜单。</p><p><img src="'+O+'" alt="" loading="lazy"></p><p><img src="'+T+'" alt="" loading="lazy"></p><p>在线分析：</p><p>附加到指定Java进程，功能强大，适合在本地附加分析优化，一般不在生产环境使用。</p><p><img src="'+A+'" alt="" loading="lazy"></p><h3 id="jconsole" tabindex="-1"><a class="header-anchor" href="#jconsole" aria-hidden="true">#</a> Jconsole</h3><p>jconsole是JDK自带的java监控和管理控制平台，能够对JMX中内存、线程和类等进行在线分析和监控，在jdk中安装目录中找到jconsole.exe即可启动，该工具功能相对于其他工具较少，在实际工作中使用较少，界面图如下：</p><p><img src="'+I+'" alt="" loading="lazy"></p><h3 id="visual-vm" tabindex="-1"><a class="header-anchor" href="#visual-vm" aria-hidden="true">#</a> Visual VM</h3><p>Visual VM是一款功能强大的故障诊断和性能监控的可视化工具，相对于jconsole来说功能更加强大，支持安装插件，支持在IDEA以插件（VisualVM Launcher）方式启动，在jdk中安装目录中找到jconsole.exe即可启动。</p><p><img src="'+U+'" alt="" loading="lazy"></p><h3 id="java-misssion-controle" tabindex="-1"><a class="header-anchor" href="#java-misssion-controle" aria-hidden="true">#</a> Java Misssion Controle</h3><p>Java Mission Control是一款Java监控工具，能够实时监控Java运行情况，双击jdk安装目录jmc.exe即可打开。</p>',33);function q(K,W){const s=t("ExternalLinkIcon");return r(),d("div",null,[E,n("p",null,[a("作用：dump分析工具。使用了jhat命令，就启动了一个http服务，端口是7000，即"),n("a",B,[a("http://localhost:7000/。"),i(s)]),a(" jhat命令在JDK9、JDK10中已经被删除，官方建议用Visua1VM代替，所以不详细了解。")]),F,n("p",null,[a("访问"),n("a",H,[a("http://localhost:7000"),i(s)]),a(",如图")]),R,n("p",null,[a("常见基础命令具体使用请参考："),n("a",N,[a("arthas官方文档"),i(s)])]),L])}const Z=l(V,[["render",q],["__file","889.JVM运维手册.html.vue"]]);export{Z as default};

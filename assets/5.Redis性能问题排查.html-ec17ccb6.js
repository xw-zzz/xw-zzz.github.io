import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as i,c as l,a as e,e as r,d as t,b as d}from"./app-ef0b4d9d.js";const p="/assets/image-20220921154918717-0d8f1733.png",o="/assets/image-20220921155552675-4c6e4184.png",c="/assets/image-20220921161522726-f07e17b3.png",m="/assets/image-20220921162340422-001575b3.png",v="/assets/3521966-8b10522a.jpeg",u={},g=d(`<h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h2><h3 id="复杂度过高的命令排查" tabindex="-1"><a class="header-anchor" href="#复杂度过高的命令排查" aria-hidden="true">#</a> 复杂度过高的命令排查</h3><ul><li><p>开启慢日志</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 命令执行耗时超过 1 毫秒，记录慢日志</span>
<span class="token key attr-name">CONFIG</span> <span class="token value attr-value">SET slowlog-log-slower-than 1000</span>
<span class="token comment"># 只保留最近 500 条慢日志</span>
<span class="token key attr-name">CONFIG</span> <span class="token value attr-value">SET slowlog-max-len 500</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>查看慢日志</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment">## 5为慢日志条数</span>
<span class="token key attr-name">SLOWLOG</span> <span class="token value attr-value">GET 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p><p><img src="`+p+`" alt="image-20220921154918717" loading="lazy"></p></li></ul><h2 id="bigkeys排查" tabindex="-1"><a class="header-anchor" href="#bigkeys排查" aria-hidden="true">#</a> bigkeys排查</h2><ul><li><p>命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token comment">## -i 扫描过程中每次扫描后休息的时间间隔，单位是秒</span>
 redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">--bigkeys</span> <span class="token parameter variable">-i</span> <span class="token number">0.01</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+o+`" alt="image-20220921155552675" loading="lazy"></p></li></ul><div class="hint-container note"><p class="hint-container-title">注</p><ol><li>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，最好控制一下扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒</li><li>扫描结果中，对于容器类型（List、Hash、Set、ZSet）的 key，只能扫描出元素最多的 key。但一个 key 的元素多，不一定表示占用内存也多，你还需要根据业务情况，进一步评估内存占用情况</li></ol></div><h3 id="集中过期" tabindex="-1"><a class="header-anchor" href="#集中过期" aria-hidden="true">#</a> 集中过期</h3><p>Redis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环。<strong>过期任务执行结束，Redis 才可以服务这个客户端请求</strong>。</p><div class="hint-container note"><p class="hint-container-title">注意</p><p>定时任务删除过期key不会出现在慢日志中，但我们的应用程序却感知到了延迟变大，其实时间都花费在了删除过期 key 上，这种情况需要尤为注意。</p></div><p>解决方案：</p><ul><li><p>增加随机过期时间</p></li><li><p>4.0以上开启lazy-free机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">lazyfree-lazy-expire</span> <span class="token value attr-value">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="fork耗时严重" tabindex="-1"><a class="header-anchor" href="#fork耗时严重" aria-hidden="true">#</a> fork耗时严重</h3><p><strong>操作 Redis 延迟变大，都发生在 Redis 后台 RDB 和 AOF rewrite 期间</strong>，fork 在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。</p><p>如何判断是否是fork操作导致耗时增加，可以使用<code>info</code>命令进行查看。</p><p><img src="`+c+`" alt="image-20220921161522726" loading="lazy"></p><h2 id="使用swap" tabindex="-1"><a class="header-anchor" href="#使用swap" aria-hidden="true">#</a> 使用swap</h2><p>Swap：操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是Swap。</p><p>Redis如果从Swap获取数据，需要先访问磁盘，会有可能造成极大的操作延时。</p><p>排查：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 先找到 Redis 的进程 ID</span>
$ <span class="token function">ps</span> <span class="token parameter variable">-aux</span> <span class="token operator">|</span> <span class="token function">grep</span> redis-server

<span class="token comment"># 查看 Redis Swap 使用情况</span>
$ <span class="token function">cat</span> /proc/<span class="token variable">$pid</span>/**aps <span class="token operator">|</span> <span class="token function">egrep</span> <span class="token string">&#39;^(Swap|Size)&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+m+`" alt="image-20220921162340422" loading="lazy"></p><h3 id="内存碎片" tabindex="-1"><a class="header-anchor" href="#内存碎片" aria-hidden="true">#</a> 内存碎片</h3><p>内存碎片形成有内部原因和外部原因：</p><ul><li><p>内部原因：内存分配器的分配策略决定操作系统无法做到“按需分配”。</p><ul><li><p>Redis使用libc、jemalloc、tcmalloc多种内存分配器来分配内存，默认使用jemalloc。</p></li><li><p>内存分配器是按照固定大小来分配内存空间，不是完全按照应用程序申请的内存大小来分配。</p><p>以jemalloc为例，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、...、2KB、4KB等。当程序申请的内存最接近某个固定值时，jemalloc就会给它分配相应大小的空间。</p></li></ul></li><li><p>外部原因：键值对大小不一样，并且键值对可以被修改和删除。</p><ul><li>Redis申请内存空间分配时，对于大小不一的内存空间需求，内存分配器按照固定大小分配内存空间，分配的内存空间一般都会比申请的内存空间大一些，这会产生一定的内存碎片。</li><li>键值对会被修改和删除，会导致空间的扩容和释放。</li></ul></li></ul><p>使用info命令查看，计算</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>INFO memory
# Memory
used_memory:350458970752
used_memory_human:326.39G
used_memory_rss:349066919936
used_memory_rss_human:325.09G
…
mem_fragmentation_ratio:1.00
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>used_memory</strong>：表示Redis为了保存数据实际申请使用的内存空间。</p></li><li><p><strong>used_memory_rss</strong>：表示操作系统实际分配给Redis的物理内存空间，其中包含了内存空间碎片。</p></li><li><p>mem_fragmentation_ratio</p><p>：表示Redis当前的内存碎片率。</p><p>计算公式：mem_fragmentation_ratio=used_memory_rss/used_memory</p><ul><li><strong>mem_fragmentation_ratio</strong>大于等于1但小于等于1.5，这种情况是合理的。</li><li><strong>mem_fragmentation_ratio</strong>大于1.5，表明内存碎片率已经超过了50%。</li></ul></li></ul><p>解决方案如下：</p><ol><li>如果你使用的是 Redis 4.0 以下版本，只能通过重启实例来解决</li><li>如果你使用的是 Redis 4.0 版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理</li></ol><p><strong>但是，开启内存碎片整理，它也有可能会导致 Redis 性能下降。</strong></p><p>原因在于，Redis 的碎片整理工作是也在<strong>主线程</strong>中执行的，当其进行碎片整理时，必然会消耗 CPU 资源，产生更多的耗时，从而影响到客户端的请求。</p><p>配置如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 开启自动内存碎片整理（总开关）</span>
<span class="token key attr-name">activedefrag</span> <span class="token value attr-value">yes</span>

<span class="token comment"># 内存使用 100MB 以下，不进行碎片整理</span>
<span class="token key attr-name">active-defrag-ignore-bytes</span> <span class="token value attr-value">100mb</span>

<span class="token comment"># 内存碎片率超过 10%，开始碎片整理</span>
<span class="token key attr-name">active-defrag-threshold-lower</span> <span class="token value attr-value">10</span>
<span class="token comment"># 内存碎片率超过 100%，尽最大努力碎片整理</span>
<span class="token key attr-name">active-defrag-threshold-upper</span> <span class="token value attr-value">100</span>

<span class="token comment"># 内存碎片整理占用 CPU 资源最小百分比</span>
<span class="token key attr-name">active-defrag-cycle-min</span> <span class="token value attr-value">1</span>
<span class="token comment"># 内存碎片整理占用 CPU 资源最大百分比</span>
<span class="token key attr-name">active-defrag-cycle-max</span> <span class="token value attr-value">25</span>

<span class="token comment"># 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量</span>
<span class="token key attr-name">active-defrag-max-scan-fields</span> <span class="token value attr-value">1000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="排查图" tabindex="-1"><a class="header-anchor" href="#排查图" aria-hidden="true">#</a> 排查图</h2><p><img src="`+v+'" alt="img" loading="lazy"></p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',36),b={href:"https://heapdump.cn/article/3523071",target:"_blank",rel:"noopener noreferrer"};function h(k,_){const a=n("ExternalLinkIcon");return i(),l("div",null,[g,e("ul",null,[e("li",null,[e("a",b,[r("Redis性能问题分析及优化（建议直接查看原文）"),t(a)])])])])}const x=s(u,[["render",h],["__file","5.Redis性能问题排查.html.vue"]]);export{x as default};

import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as r,f as a,a as e,b as o}from"./app-ef0b4d9d.js";const t={},d=e("h2",{id:"",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#","aria-hidden":"true"},"#")],-1),s=o('<p>解码一般用于入站时使用，主要就是字节数组转换为消息对象。</p><ul><li><p>主要是两个方法<br> decode 一般用这个<br> decodeLast 一般用于最后几个字节处理</p></li><li><p>抽象解码器</p><ul><li>ByteToMessageDecoder用于将字节转为消息，需要检查缓冲区是否有足够的字节</li><li>ReplayingDecoder继承ByteToMessageDecoder，不需要检查缓冲区是否有足够的字节，但是ReplayingDecoder速度略慢于ByteToMessageDecoder，不是所有的ByteBuf都支持</li><li>选择：项目复杂性高则使用ReplayingDecoder，否则使用 ByteToMessageDecoder</li><li>MessageToMessageDecoder用于从一种消息解码为另外一种消息（例如POJO到POJO）</li></ul></li><li><p>解码器具体的实现，用的比较多的是(更多是为了解决TCP底层的粘包和拆包问题)</p><ul><li>DelimiterBasedFrameDecoder： 指定消息分隔符的解码器</li><li>LineBasedFrameDecoder: 以换行符为结束标志的解码器</li><li>FixedLengthFrameDecoder：固定长度解码器</li><li>LengthFieldBasedFrameDecoder：message = header+body, 基于长度解码的通用解码器</li><li>StringDecoder：文本解码器，将接收到的对象转化为字符串，一般会与上面的进行配合，然后在后面添加业务handle。</li></ul></li></ul><h2 id="netty编码器encoder" tabindex="-1"><a class="header-anchor" href="#netty编码器encoder" aria-hidden="true">#</a> <strong>Netty编码器Encoder</strong></h2><ul><li>Encoder对应的就是ChannelOutboundHandler，消息对象转换为字节数组</li><li>Netty本身未提供和解码一样的编码器，是因为场景不同，两者非对等的</li><li>MessageToByteEncoder消息转为字节数组,调用write方法，会先判断当前编码器是否支持需要发送的消息类型，如果不支持，则透传；</li><li>MessageToMessageEncoder用于从一种消息编码为另外一种消息（例如POJO到POJO）</li></ul>',4);function c(n,_){return l(),r("div",null,[d,a("more"),s])}const u=i(t,[["render",c],["__file","2.Netty学习笔记三编码解码.html.vue"]]);export{u as default};

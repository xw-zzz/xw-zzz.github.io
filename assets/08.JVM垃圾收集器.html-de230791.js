import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,b as l}from"./app-ef0b4d9d.js";const r="/assets/image-20220906151437664-108e20f3.png",n="/assets/image-20220906151744829-d41899db.png",t="/assets/image-20220906152337521-bbd2e7b5.png",s={},o=l('<h2 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器" aria-hidden="true">#</a> Serial收集器</h2><p>Serial收集器是一个单线程的收集器,它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。<strong>新生代采取复制算法暂停所有用户线程，老年代采取标记-整理算法暂停所有用户线程。它是虚拟机运行在Client模式下的默认新生代收集器</strong>。</p><p><img src="'+r+'" alt="image-20220906151437664" loading="lazy"></p><h2 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器" aria-hidden="true">#</a> ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他基本一致。</p><p><img src="'+n+'" alt="image-20220906151744829" loading="lazy"></p><h2 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器" aria-hidden="true">#</a> Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。</p><div class="hint-container note"><p class="hint-container-title">吞吐量计算公式</p><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间）</p></div><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><h2 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器" aria-hidden="true">#</a> CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>CMS收集器是基于“标记—清除”算法实现的，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p><img src="'+t+'" alt="image-20220906152337521" loading="lazy"></p><p>CMS主打并发收集、低停顿，但也有几个明显的缺点：</p><ul><li>CMS收集器对CPU资源非常敏感</li><li>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li><li>CMS是一款基于“标记—清除”算法实现的收集器。收集结束时可能会有大量空间碎片产生</li></ul><h2 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器" aria-hidden="true">#</a> G1收集器</h2><p>G1是一款面向服务端应用的垃圾收集器，与其他GC收集器相比，G1具备如下特点。</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：与CMS的“标记—清理”算法不同，G1从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着<strong>G1运作期间不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。</li><li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><div class="hint-container note"><p class="hint-container-title">注</p><p>相对于以前的垃圾收集器，G1新引入了Region的概念，将堆内存分成多个Region进行管理，在管理大内存堆上是一个很大的突破。</p></div>',22),c=[o];function p(d,h){return e(),i("div",null,c)}const _=a(s,[["render",p],["__file","08.JVM垃圾收集器.html.vue"]]);export{_ as default};

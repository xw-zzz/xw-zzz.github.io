import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as s,f as d,a as e,e as a,b as c}from"./app-ef0b4d9d.js";const _={},o=e("h2",{id:"简介",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),a(" 简介")],-1),n=e("p",null,[a("TCP 拆包: 一个完整的包可能会被 TCP 拆分为多个包进行发送"),e("br"),a(" TCP 粘包: 把多个小的包封装成一个大的数据包发送, client 发送的若干数据包 Server 接收时粘成一包"),e("br"),a(" 发送方和接收方都可能出现这个原因"),e("br"),a(" 发送方的原因：TCP 默认会使用 Nagle 算法。Nagle 算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。"),e("br"),a(" 接收方的原因: TCP 接收到数据放置缓存中，应用程序从缓存中读取。")],-1),i=c('<h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p>发送方：关闭 Nagle 算法。<br> 接收方:<br> TCP 是无界的数据流，并没有处理粘包现象的机制, 且协议本身无法避免粘包，半包读写的发生需要在应用层进行处理<br> 应用层解决半包读写的办法<br> 1）设置定长消息 (10 字符)<br> xdclass000xdclass000xdclass000xdclass000<br> 2）设置消息的边界 ($$ 切割)<br> sdfafwefqwefwe$$dsafadfadsfwqehidwuehfiw$$879329832r89qweew$$<br> 3）使用带消息头的协议，消息头存储消息开始标识及消息的长度信息<br> Header+Body</p>',2);function l(f,h){return t(),s("div",null,[o,n,d("more"),i])}const x=r(_,[["render",l],["__file","4.Netty学习笔记四粘包拆包.html.vue"]]);export{x as default};

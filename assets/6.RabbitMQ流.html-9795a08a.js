import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,b as t}from"./app-ef0b4d9d.js";const h={},i=t('<h1 id="什么是流" tabindex="-1"><a class="header-anchor" href="#什么是流" aria-hidden="true">#</a> 什么是流</h1><p>RabbitMQ Streams 是一种持久复制的数据结构，可以完成与队列相同的任务：它们缓冲来自生产者的消息并由消费者读取。然而，流与队列有两个重要的不同之处：消息的存储和使用方式。<strong>流对消息的仅附加日志进行建模，可以重复读取该消息直到过期。流总是持久且可复制的。要从 RabbitMQ 中的流读取消息，一个或多个消费者订阅该流并根据需要多次读取相同的消息。</strong></p><h1 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h1><h2 id="大量的消费者消费同一消息场景" tabindex="-1"><a class="header-anchor" href="#大量的消费者消费同一消息场景" aria-hidden="true">#</a> 大量的消费者消费同一消息场景</h2><p>当想要向多个订阅者传递相同的消息时，用户当前必须为每个消费者绑定专用队列。如果消费者数量很大，这可能会变得低效，特别是在需要持久性和/或复制时。流将允许任意数量的消费者以非破坏性的方式使用来自同一队列的相同消息，从而无需绑定多个队列。流消费者还可以从副本中读取数据，从而允许读取负载分布在整个集群中。</p><h2 id="重复读取" tabindex="-1"><a class="header-anchor" href="#重复读取" aria-hidden="true">#</a> 重复读取</h2><p>由于所有当前的 RabbitMQ 队列类型都具有破坏性的消费行为，即当消费者使用完消息后，消息将从队列中删除，因此不可能重新读取已消费的消息。流将允许消费者附加到日志中的任何点并从那里读取。</p><h2 id="高吞吐量性能" tabindex="-1"><a class="header-anchor" href="#高吞吐量性能" aria-hidden="true">#</a> 高吞吐量性能</h2><p>没有持久队列类型能够提供可以与任何现有的基于日志的消息传递系统竞争的吞吐量。 Streams 的设计以性能为主要目标。</p><h2 id="大量积压" tabindex="-1"><a class="header-anchor" href="#大量积压" aria-hidden="true">#</a> 大量积压</h2><p>大多数 RabbitMQ 队列设计为向空状态收敛并进行优化，当给定队列上有数百万条消息时，性能可能会更差。流旨在以最小的内存开销有效地存储大量数据。</p>',11),d=[i];function n(s,c){return e(),r("div",null,d)}const _=a(h,[["render",n],["__file","6.RabbitMQ流.html.vue"]]);export{_ as default};
